<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Kinematics & Projectile Motion Calculator</title>
  <style>
    /* --- Light Mode Variables (Default) --- */
    :root {
      --primary-color: #0056b3;
      --secondary-color: #f8f9fa; /* Body background */
      --container-bg: #ffffff; /* Container background */
      --text-color: #212529; /* Main text */
      --label-color: #495057; /* Labels */
      --border-color: #dee2e6; /* Borders */
      --input-bg: #ffffff; /* Input background */
      --input-text: #495057; /* Input text */
      --input-focus-border: #86b7fe; /* Input focus border */
      --input-focus-shadow: rgba(0, 123, 255, 0.25); /* Input focus shadow */
      --success-bg: #d1e7dd;
      --success-text: #0f5132;
      --success-border: #badbcc;
      --error-bg: #f8d7da;
      --error-text: #842029;
      --error-border: #f5c2c7;
      --note-bg: #fff3cd;
      --note-text: #664d03;
      --note-border: #ffecb5;
      --shadow-color: rgba(0, 0, 0, 0.1);
      --button-bg: #ffffff;
      --button-hover-bg: #e9ecef;
      --button-border: #ced4da;
      --radio-checked-bg: #e7f1ff;
      --radio-checked-border: var(--primary-color);
      --canvas-bg: #ffffff;
      /* We now hardcode the trajectory colour to blue in the drawing functions */
      --trajectory-color: #aaccee;
      --marker-text-color: #000000;
      --state-display-bg: #ffffff;
      --state-display-border: var(--border-color);
      --state-display-text: var(--text-color);
      --axis-color: rgba(128, 128, 128, 0.5);
      --border-radius: 8px;
      --spacing-unit: 1rem;
    }

    /* --- Dark Mode Variables --- */
    @media (prefers-color-scheme: dark) {
      :root {
        --primary-color: #58a6ff;
        --secondary-color: #0d1117;
        --container-bg: #161b22;
        --text-color: #c9d1d9;
        --label-color: #8b949e;
        --border-color: #30363d;
        --input-bg: #0d1117;
        --input-text: #c9d1d9;
        --input-focus-border: #58a6ff;
        --input-focus-shadow: rgba(88, 166, 255, 0.25);
        --success-bg: #0f2d1f;
        --success-text: #56d364;
        --success-border: #1a472a;
        --error-bg: #35191c;
        --error-text: #f87171;
        --error-border: #58292d;
        --note-bg: #3a2c0f;
        --note-text: #eac54f;
        --note-border: #6e551a;
        --shadow-color: rgba(0, 0, 0, 0.4);
        --button-bg: #21262d;
        --button-hover-bg: #30363d;
        --button-border: #30363d;
        --radio-checked-bg: #1f6feb;
        --radio-checked-border: var(--primary-color);
        --canvas-bg: #1a1f27;
        --trajectory-color: #58a6ff;
        --marker-text-color: #c9d1d9;
        --state-display-bg: #161b22;
        --state-display-border: var(--border-color);
        --state-display-text: var(--text-color);
        --axis-color: rgba(160, 160, 160, 0.4);
      }
    }

    /* --- Base & Layout Styles --- */
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    html {
      scroll-behavior: smooth;
      font-size: 16px;
      color-scheme: light dark;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji";
      background-color: var(--secondary-color);
      color: var(--text-color);
      line-height: 1.6;
      padding: var(--spacing-unit);
      display: flex;
      justify-content: center;
      align-items: flex-start;
      min-height: 100vh;
      transition: background-color 0.3s ease, color 0.3s ease;
    }

    .wrapper {
      width: 100%;
      max-width: 1200px;
      display: flex;
      flex-direction: column;
      gap: 2rem;
    }

    .top-container {
      display: flex;
      flex-direction: column;
      gap: 2rem;
    }

    @media (min-width: 900px) {
      .top-container {
        flex-direction: row;
      }
    }

    .container {
      background-color: var(--container-bg);
      border-radius: var(--border-radius);
      box-shadow: 0 4px 12px var(--shadow-color);
      padding: 2rem;
      flex: 1;
      border: 1px solid var(--border-color);
      transition: background-color 0.3s ease, border-color 0.3s ease;
    }

    h1 {
      font-size: 1.5rem;
      color: var(--primary-color);
      margin-bottom: 0;
    }

    h2 {
      margin-bottom: 1rem;
      color: var(--primary-color);
      font-size: 1.25rem;
      border-bottom: 1px solid var(--border-color);
      padding-bottom: 0.5rem;
    }

    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1.5rem;
      flex-wrap: wrap;
      gap: 1rem;
    }

    .form-group {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      margin-bottom: 1rem;
      gap: 0.5rem;
    }

    .form-group label {
      flex: 0 0 250px;
      font-weight: 500;
      color: var(--label-color);
      padding-right: 0.5rem;
    }

    .form-group input[type="number"] {
      flex: 1;
      min-width: 120px;
      padding: 0.6rem 0.75rem;
      border-radius: var(--border-radius);
      border: 1px solid var(--border-color);
      background-color: var(--input-bg);
      color: var(--input-text);
      font-size: 1rem;
      transition: box-shadow 0.2s ease, border-color 0.2s ease, background-color 0.3s ease, color 0.3s ease;
    }

    .form-group input[type="number"]:focus {
      outline: none;
      border-color: var(--input-focus-border);
      box-shadow: 0 0 0 3px var(--input-focus-shadow);
    }

    .unit {
      font-size: 0.85rem;
      color: var(--label-color);
      margin-left: 0.25rem;
      opacity: 0.8;
    }

    .modeToggle {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
    }

    .modeToggle input[type="radio"] {
      display: none;
    }

    .modeToggle label {
      padding: 0.5rem 1rem;
      border: 1px solid var(--button-border);
      border-radius: var(--border-radius);
      background-color: var(--button-bg);
      color: var(--text-color);
      cursor: pointer;
      transition: background-color 0.2s ease, border-color 0.2s ease, color 0.2s ease;
      font-weight: 500;
    }

    .modeToggle label:hover {
      background-color: var(--button-hover-bg);
    }

    .modeToggle input[type="radio"]:checked + label {
      background-color: var(--radio-checked-bg);
      border-color: var(--radio-checked-border);
      color: var(--primary-color);
      font-weight: 600;
    }

    @media (prefers-color-scheme: dark) {
      .modeToggle input[type="radio"]:checked + label {
        color: #ffffff;
      }
    }

    .note, .error, .result {
      margin-top: 1.5rem;
      padding: 1rem 1.25rem;
      border-radius: var(--border-radius);
      border-width: 1px;
      border-style: solid;
      transition: background-color 0.3s ease, border-color 0.3s ease, color 0.3s ease;
    }

    .error {
      background-color: var(--error-bg);
      color: var(--error-text);
      border-color: var(--error-border);
    }

    .result {
      background-color: var(--success-bg);
      color: var(--success-text);
      border-color: var(--success-border);
    }

    .note {
      background-color: var(--note-bg);
      color: var(--note-text);
      border-color: var(--note-border);
      margin-bottom: 1rem;
    }

    .result .group-title {
      font-weight: 600;
      font-size: 1.1rem;
      margin-top: 1.5rem;
      margin-bottom: 0.75rem;
      border-bottom: 1px solid var(--border-color);
      padding-bottom: 0.35rem;
      color: var(--primary-color);
    }

    .result .group-title:first-of-type {
      margin-top: 0;
    }

    .result p {
      margin-bottom: 0.6rem;
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
    }

    .result p strong {
      font-weight: 500;
      display: inline-block;
      min-width: 210px;
      color: var(--label-color);
    }

    .result p span:not(.unit) {
      color: var(--text-color);
      font-weight: 400;
    }

    .hidden {
      display: none !important;
    }

    /* --- Trajectory Panel --- */
    #trajectoryPanel {
      margin-top: 2rem;
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
    }

/* --- New Trajectory Panel Inner Layout --- */
#trajectoryPanelInner {
  display: flex;
  gap: 1.5rem;
  align-items: flex-start;
}

/* On small screens, stack the two containers vertically */
@media (max-width: 600px) {
  #trajectoryPanelInner {
    flex-direction: column;
  }
}

/* Container for the trajectory canvas, slider, and buttons */
#trajectoryContainer {
  flex: 2;
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
}

/* Container for the current state display */
#stateDisplayContainer {
  flex: 1 1 0;
  min-width: 0;
}



    /* New container for the main trajectory display */
    #trajectoryMain {
      display: flex;
      gap: 1.5rem;
      flex-wrap: wrap;
      align-items: flex-start;
    }
    
    /* Ensure that on small screens the canvas and state display stack vertically */
    @media (max-width: 600px) {
      #trajectoryMain {
        flex-direction: column;
      }
    }

    #trajectoryCanvas {
     
      border: 1px solid var(--border-color);
      border-radius: var(--border-radius);
      background-color: var(--canvas-bg);
      transition: background-color 0.3s ease, border-color 0.3s ease;
      display: block;
      width: 100%;
	  max-width: 800px;
      height: auto;
      aspect-ratio: 800 / 300;
    }

    #stateDisplay {
      flex: 1 1 200px;
      min-width: 180px;
      border: 1px solid var(--state-display-border);
      border-radius: var(--border-radius);
      background-color: var(--state-display-bg);
      color: var(--state-display-text);
      padding: 1rem;
      font-size: 0.9rem;
      transition: background-color 0.3s ease, border-color 0.3s ease, color 0.3s ease;
    }

    #stateDisplay h3 {
      font-size: 1rem;
      margin-bottom: 0.75rem;
      color: var(--primary-color);
      border-bottom: 1px solid var(--border-color);
      padding-bottom: 0.3rem;
    }

    #stateDisplay p {
      margin-bottom: 0.4rem;
      display: flex;
      justify-content: space-between;
    }

    #stateDisplay p strong {
      color: var(--label-color);
      font-weight: 500;
    }

    /* --- Trajectory Controls (New Container) --- */
    #trajectoryControls {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }
    
    #trajectoryControls .buttonContainer {
      display: flex;
      justify-content: center;
      gap: 0.5rem;
    }
    
    #trajectorySlider {
      width: 100%;
      cursor: pointer;
    }

    #startStopButton, #resetButton {
      padding: 0.6rem 1.2rem;
      font-size: 0.95rem;
      border: 1px solid var(--button-border);
      border-radius: var(--border-radius);
      background-color: var(--button-bg);
      color: var(--text-color);
      cursor: pointer;
      transition: background-color 0.2s ease, border-color 0.2s ease;
      font-weight: 500;
    }

    #startStopButton:hover, #resetButton:hover {
      background-color: var(--button-hover-bg);
      border-color: var(--primary-color);
    }

    #startStopButton:active, #resetButton:active {
      transform: scale(0.98);
    }
  </style>
</head>
<body>
  <div class="wrapper">
    <div class="top-container">
      <div class="container" id="inputContainer">
        <div class="header">
          <h1>Kinematics Calculator</h1>
          <div class="modeToggle">
            <input type="radio" name="mode" id="mode1D" value="1d" checked />
            <label for="mode1D">1D</label>
            <input type="radio" name="mode" id="mode2D" value="basic" />
            <label for="mode2D">2D</label>
            <input type="radio" name="mode" id="modeDesign" value="design" />
            <label for="modeDesign">Design</label>
          </div>
        </div>
        <div id="oneDInputs">
          <p class="note">Fill in <strong>exactly three</strong> of the following five fields. The two missing variables will be calculated.</p>
          <div class="form-group">
            <label for="v1d">Initial Velocity, V<sub>i</sub> <span class="unit">(m/s)</span></label>
            <input type="number" id="v1d" placeholder="e.g., 5" />
          </div>
          <div class="form-group">
            <label for="vf1d">Final Velocity, V<sub>f</sub> <span class="unit">(m/s)</span></label>
            <input type="number" id="vf1d" placeholder="e.g., 10" />
          </div>
          <div class="form-group">
            <label for="a1d">Acceleration, a <span class="unit">(m/s²)</span></label>
            <input type="number" id="a1d" placeholder="e.g., 2" />
          </div>
          <div class="form-group">
            <label for="d1d">Displacement, d <span class="unit">(m)</span></label>
            <input type="number" id="d1d" placeholder="e.g., 20" />
          </div>
          <div class="form-group">
            <label for="t1d">Time, t <span class="unit">(s)</span></label>
            <input type="number" id="t1d" placeholder="e.g., 4" />
          </div>
        </div>
        <div id="basicInputs" class="hidden">
          <p class="note">Fill in <strong>exactly three</strong> of these fields: Initial Velocity (V<sub>i</sub>), &Delta;x, &Delta;y, and Launch Angle (&theta;). Time (t) is optional.</p>
          <div class="form-group">
            <label for="vi">Initial Velocity, V<sub>i</sub> <span class="unit">(m/s)</span></label>
            <input type="number" id="vi" placeholder="e.g., 20" />
          </div>
          <div class="form-group">
            <label for="dx">Horizontal Displacement, &Delta;x <span class="unit">(m)</span></label>
            <input type="number" id="dx" placeholder="e.g., 30" />
          </div>
          <div class="form-group">
            <label for="dy">Vertical Displacement, &Delta;y <span class="unit">(m)</span></label>
            <input type="number" id="dy" placeholder="e.g., 5" />
          </div>
          <div class="form-group">
            <label for="angle">Launch Angle, &theta; <span class="unit">(°)</span></label>
            <input type="number" id="angle" placeholder="e.g., 45" />
          </div>
          <div class="form-group">
            <label for="time">Time (optional), t <span class="unit">(s)</span></label>
            <input type="number" id="time" placeholder="e.g., 2.5" />
          </div>
        </div>
        <div id="designInputs" class="hidden">
          <p class="note">Enter target displacements (&Delta;x and &Delta;y) and the desired landing angle (&phi;). The calculator computes the required launch angle and initial speed.</p>
          <div class="form-group">
            <label for="dxDesign">Target &Delta;x <span class="unit">(m)</span></label>
            <input type="number" id="dxDesign" placeholder="e.g., 3" />
          </div>
          <div class="form-group">
            <label for="dyDesign">Target &Delta;y <span class="unit">(m)</span></label>
            <input type="number" id="dyDesign" placeholder="e.g., 1.2" />
          </div>
          <div class="form-group">
            <label for="landingAngle">Landing Angle, &phi; <span class="unit">(°)</span></label>
            <input type="number" id="landingAngle" placeholder="e.g., -30" />
          </div>
        </div>
        <div id="gravityBox" class="form-group hidden" style="margin-top: var(--spacing-unit); border-top: 1px solid var(--border-color); padding-top: var(--spacing-unit);">
          <label for="acceleration">Gravitational Accel., g <span class="unit">(m/s²)</span></label>
          <input type="number" id="acceleration" placeholder="e.g., 9.81" value="9.81" />
        </div>
      </div>
      <div class="container" id="resultContainer">
        <h2>Results</h2>
        <div id="message">
          <p class="note">Enter parameters in the relevant section on the left to see results.</p>
        </div>
      </div>
    </div>
    <div class="container hidden" id="trajectoryPanel">
  <h2>Trajectory Visualization</h2>
  <div id="trajectoryPanelInner">
    <!-- Container for canvas, slider, and buttons -->
    <div id="trajectoryContainer">
      <canvas id="trajectoryCanvas" width="800" height="300"></canvas>
      <div id="trajectoryControls">
        <input type="range" id="trajectorySlider" min="0" max="100" value="0" step="0.1" />
        <div class="buttonContainer">
          <button id="startStopButton">Start</button>
          <button id="resetButton">Reset</button>
        </div>
      </div>
    </div>
    <!-- Separate container for the current state display -->
    <div id="stateDisplayContainer">
      <div id="stateDisplay">
        <h3>Current State</h3>
        <div id="stateValues">
          <p><strong>Time:</strong> <span>-- s</span></p>
          <p><strong>dx:</strong> <span>-- m</span></p>
          <p><strong>dy:</strong> <span>-- m</span></p>
          <p><strong>vx:</strong> <span>-- m/s</span></p>
          <p><strong>vy:</strong> <span>-- m/s</span></p>
          <p><strong>Speed:</strong> <span>-- m/s</span></p>
          <p><strong>Angle:</strong> <span>-- °</span></p>
        </div>
      </div>
    </div>
  </div>
</div>

    <script>
      // --- Constants ---
      const G_DEFAULT = 9.81; // Default gravitational acceleration
      const TOLERANCE = 1e-9; // For floating-point comparisons
      const ANIMATION_DURATION = 3000; // 3000ms for full animation playback

      // --- Global State Variables ---
      let globalPoints = []; // Trajectory points
      let globalScale = 1; // Canvas scale factor
      let globalOffsetX = 0; // X offset for centering
      let globalOffsetY = 0; // Y offset for centering
      let global_t_flight = 0; // Total flight time
      let globalVix = 0; // Initial horizontal velocity (for animation)
      let globalViy = 0; // Initial vertical velocity (for animation)
      let globalG = G_DEFAULT; // Gravity used in current calculation
      let globalVerticalShift = 0; // Vertical shift applied to trajectory

      // Animation control
      let animationFrameId = null;
      let autoAnimating = false;
      let animationStartTime = null;
      let pausedProgress = 0;

      // --- DOM Elements ---
      const modeRadios = document.getElementsByName("mode");
      const oneDInputsDiv = document.getElementById("oneDInputs");
      const basicInputsDiv = document.getElementById("basicInputs");
      const designInputsDiv = document.getElementById("designInputs");
      const gravityBox = document.getElementById("gravityBox");
      const messageDiv = document.getElementById("message");
      const startStopButton = document.getElementById("startStopButton");
      const resetButton = document.getElementById("resetButton");
      const trajectorySlider = document.getElementById("trajectorySlider");
      const allNumberInputs = document.querySelectorAll("input[type='number']");
      const stateDisplayValues = document.getElementById("stateValues");
      const trajectoryPanel = document.getElementById("trajectoryPanel");
      const trajectoryCanvas = document.getElementById("trajectoryCanvas");
      const resultContainer = document.getElementById("resultContainer");

      // --- Event Listeners ---
      document.addEventListener("DOMContentLoaded", () => {
          modeRadios.forEach(radio => radio.addEventListener("change", handleModeChange));
          allNumberInputs.forEach(input => input.addEventListener("input", debounce(calculate, 250)));
          if (startStopButton) startStopButton.addEventListener("click", toggleAnimation);
          if (resetButton) resetButton.addEventListener("click", resetAnimation);
          trajectorySlider.addEventListener("input", handleSliderInput);
          trajectorySlider.addEventListener("change", handleSliderChange);
          updateModeVisibility();
          calculate();
      });

      // --- Debounce Function ---
      function debounce(func, wait) {
          let timeout;
          return function executedFunction(...args) {
              const later = () => {
                  clearTimeout(timeout);
                  func.apply(this, args);
              };
              clearTimeout(timeout);
              timeout = setTimeout(later, wait);
          };
      }

      // --- Mode Switching Logic ---
      function handleModeChange() {
          updateModeVisibility();
          calculate();
      }

      function getSelectedMode() {
          const checkedRadio = document.querySelector("input[name='mode']:checked");
          return checkedRadio ? checkedRadio.value : "1d";
      }

      function updateModeVisibility() {
          const mode = getSelectedMode();
          oneDInputsDiv.classList.toggle("hidden", mode !== "1d");
          basicInputsDiv.classList.toggle("hidden", mode !== "basic");
          designInputsDiv.classList.toggle("hidden", mode !== "design");
          gravityBox.classList.toggle("hidden", mode === "1d");
          trajectoryPanel.classList.toggle("hidden", mode === "1d");
          clearMessages();
          if (mode === '1d') {
               showNote("1D Mode: Fill in <strong>exactly three</strong> fields.");
          } else if (mode === 'basic') {
               showNote("2D Mode: Fill in <strong>exactly three</strong> of V<sub>i</sub>, &Delta;x, &Delta;y, &theta;.");
          } else if (mode === 'design') {
               showNote("Design Mode: Fill in target &Delta;x, &Delta;y, and landing angle &phi;.");
          }
          resetAnimation();
      }

      // --- Message Display Functions ---
      function clearMessages() {
          messageDiv.innerHTML = "";
      }

      function showResult(htmlContent) {
           clearMessages();
           if (!resultContainer.querySelector('h2')) {
               resultContainer.insertAdjacentHTML('afterbegin', '<h2>Results</h2>');
           }
           messageDiv.innerHTML = `<div class="result">${htmlContent}</div>`;
      }

      function showError(text) {
           clearMessages();
           if (!resultContainer.querySelector('h2')) {
               resultContainer.insertAdjacentHTML('afterbegin', '<h2>Results</h2>');
           }
           messageDiv.innerHTML = `<div class="error">${text}</div>`;
      }

      function showNote(text) {
           clearMessages();
           if (!resultContainer.querySelector('h2')) {
               resultContainer.insertAdjacentHTML('afterbegin', '<h2>Results</h2>');
           }
           messageDiv.innerHTML = `<div class="note">${text}</div>`;
      }

      // --- Input Parsing ---
      function getFloatValue(id, allowEmpty = false) {
          const element = document.getElementById(id);
          if (!element) return NaN;
          const value = element.value.trim();
          if (value === "") {
              return allowEmpty ? null : NaN;
          }
          const num = parseFloat(value);
          return isNaN(num) ? NaN : num;
      }

      // --- Result Formatting ---
      function formatResultLine(label, value, unit) {
          let displayValue;
          if (typeof value === "number" && isFinite(value)) {
              const precision = (label.includes("&theta;") || label.includes("&phi;")) ? 3 : 2;
              displayValue = (Math.abs(value) < TOLERANCE * 10) ? (0).toFixed(precision) : value.toFixed(precision);
          } else {
              displayValue = value;
          }
          return `<p><strong>${label}:</strong> <span>${displayValue}</span> <span class="unit">${unit}</span></p>`;
      }

      // --- 1D Kinematics Calculation (unchanged) ---
      function calculate1DMode() {
          const vi = getFloatValue("v1d", true);
          const vf = getFloatValue("vf1d", true);
          const a = getFloatValue("a1d", true);
          const d = getFloatValue("d1d", true);
          const t = getFloatValue("t1d", true);

          const variables = { vi, vf, a, d, t };
          const providedKeys = Object.keys(variables).filter(key => variables[key] !== null && isFinite(variables[key]));

          if (providedKeys.length !== 3) {
              showNote("1D Mode: Please fill in exactly <strong>three</strong> fields.");
              return;
          }

          let sol = { ...variables };
          const has = {
              vi: providedKeys.includes("vi"),
              vf: providedKeys.includes("vf"),
              a: providedKeys.includes("a"),
              d: providedKeys.includes("d"),
              t: providedKeys.includes("t")
          };

          try {
              if (has.vi && has.vf && has.t) {
                  if (Math.abs(sol.t) < TOLERANCE) throw new Error("Time (t) cannot be zero.");
                  sol.a = (sol.vf - sol.vi) / sol.t;
                  sol.d = sol.vi * sol.t + 0.5 * sol.a * sol.t * sol.t;
              } else if (has.vi && has.vf && has.a) {
                  sol.t = (sol.vf - sol.vi) / sol.a;
                  sol.d = sol.vi * sol.t + 0.5 * sol.a * sol.t * sol.t;
              } else if (has.vi && has.vf && has.d) {
                  const v_avg = (sol.vi + sol.vf) / 2;
                  if (Math.abs(v_avg) < TOLERANCE) {
                       if (Math.abs(sol.d) > TOLERANCE) throw new Error("Displacement must be zero if average velocity is zero.");
                       sol.t = 0;
                       sol.a = NaN;
                  } else {
                      sol.t = sol.d / v_avg;
                  }
                  if (sol.t < -TOLERANCE) throw new Error("Calculation resulted in negative time.");
                  sol.t = Math.max(0, sol.t);
                  if (Math.abs(sol.t) < TOLERANCE) {
                       if(Math.abs(sol.vf - sol.vi) > TOLERANCE) throw new Error("Vf and Vi must be equal if time is zero.");
                       sol.a = NaN;
                  } else {
                       sol.a = (sol.vf - sol.vi) / sol.t;
                  }
              } else if (has.vi && has.a && has.t) {
                  sol.vf = sol.vi + sol.a * sol.t;
                  sol.d = sol.vi * sol.t + 0.5 * sol.a * sol.t * sol.t;
              } else if (has.vi && has.a && has.d) {
                   const A = 0.5 * sol.a;
                   const B = sol.vi;
                   const C = -sol.d;
                   if (Math.abs(A) < TOLERANCE) {
                       if (Math.abs(B) < TOLERANCE) {
                           if (Math.abs(C) > TOLERANCE) throw new Error("Displacement must be zero if Vi and a are zero.");
                           sol.t = 0;
                       } else {
                           sol.t = -C / B;
                       }
                   } else {
                       const disc = B * B - 4 * A * C;
                       if (disc < -TOLERANCE) throw new Error("No real solution for time.");
                       const sqrtDisc = Math.sqrt(Math.max(0, disc));
                       const t1 = (-B + sqrtDisc) / (2 * A);
                       const t2 = (-B - sqrtDisc) / (2 * A);
                       if (t1 >= -TOLERANCE && (t1 < t2 || t2 < -TOLERANCE)) sol.t = t1;
                       else if (t2 >= -TOLERANCE) sol.t = t2;
                       else throw new Error("No positive real solution for time.");
                   }
                   sol.t = Math.max(0, sol.t);
                   sol.vf = sol.vi + sol.a * sol.t;
              } else if (has.vi && has.t && has.d) {
                  sol.a = 2 * (sol.d - sol.vi * sol.t) / (sol.t * sol.t);
                  sol.vf = sol.vi + sol.a * sol.t;
              } else if (has.vf && has.a && has.t) {
                  sol.vi = sol.vf - sol.a * sol.t;
                  sol.d = sol.vi * sol.t + 0.5 * sol.a * sol.t * sol.t;
              } else if (has.vf && has.a && has.d) {
                  const A = 0.5 * sol.a;
                  const B = -sol.vf;
                  const C = sol.d;
                  const disc = B * B - 4 * A * C;
                  if (disc < -TOLERANCE) throw new Error("No real solution for time.");
                  const t1 = (-B + Math.sqrt(disc)) / (2 * A);
                  const t2 = (-B - Math.sqrt(disc)) / (2 * A);
                  sol.t = (t1 >= -TOLERANCE ? t1 : t2);
                  sol.vi = sol.vf - sol.a * sol.t;
              } else if (has.vf && has.t && has.d) {
                  sol.vi = (2 * sol.d) / sol.t - sol.vf;
                  sol.a = (sol.vf - sol.vi) / sol.t;
              } else if (has.a && has.t && has.d) {
                  sol.vi = (sol.d - 0.5 * sol.a * sol.t * sol.t) / sol.t;
                  sol.vf = sol.vi + sol.a * sol.t;
              } else {
                  throw new Error("Unexpected combination of inputs.");
              }

              let resultHTML = `<div class="result"><div class="group-title">1D Kinematics Results</div>`;
              resultHTML += formatResultLine("Initial Velocity, V<sub>i</sub>", sol.vi, "m/s");
              resultHTML += formatResultLine("Final Velocity, V<sub>f</sub>", sol.vf, "m/s");
              resultHTML += formatResultLine("Acceleration, a", sol.a, "m/s²");
              resultHTML += formatResultLine("Displacement, d", sol.d, "m");
              resultHTML += formatResultLine("Time, t", sol.t, "s");
              resultHTML += `</div>`;
              showResult(resultHTML);

          } catch (e) {
              console.error("1D Calc Error:", e);
              showError("1D Calculation Error: " + e.message);
          }
        }

        // --- 2D Projectile Motion Calculation ---
        function calculateBasicMode(g) {
            globalG = g;
            const vi = getFloatValue("vi", true);
            const dx = getFloatValue("dx", true);
            const dy = getFloatValue("dy", true);
            const angleDeg = getFloatValue("angle", true);
            const timeOptional = getFloatValue("time", true);
            const inputs = { vi, dx, dy, angle: angleDeg };
            let providedCount = 0;
            let missingKeys = [];
            for (const key in inputs) {
                const value = inputs[key];
                if (value !== null && isFinite(value)) {
                    providedCount++;
                } else {
                    missingKeys.push(key);
                }
            }
            if (providedCount !== 3) {
                showNote("2D: Please fill in exactly <strong>three</strong> of V<sub>i</sub>, &Delta;x, &Delta;y, &theta;.");
                resetAnimation();
                return;
            }
            if (missingKeys.length !== 1) {
                console.error("Internal Error:", missingKeys);
                showError("Internal error: Could not determine the variable to calculate.");
                resetAnimation();
                return;
            }
            const missingVar = missingKeys[0];
            let t_flight, finalVi, finalAngleRad, finalDx, finalDy;
            let angleRad = (inputs.angle !== null && isFinite(inputs.angle)) ? inputs.angle * Math.PI / 180 : null;
            let tan1, angle1, angle2;
            try {
                switch (missingVar) {
                    case "dx":
                        if (inputs.vi === null || angleRad === null || inputs.dy === null) throw new Error("Inputs V<sub>i</sub>, &theta;, and &Delta;y are required.");
                        finalVi = inputs.vi;
                        finalAngleRad = angleRad;
                        finalDy = inputs.dy;
                        if (finalVi <= 0) throw new Error("Initial velocity must be positive.");
                        const Viy_calc = finalVi * Math.sin(finalAngleRad);
                        const A = 0.5 * g;
                        const B = -Viy_calc;
                        const C = finalDy;
                        const disc = B * B - 4 * A * C;
                        if (disc < -TOLERANCE) throw new Error("No real solution for time.");
                        const sqrtDisc = Math.sqrt(Math.max(0, disc));
                        const t1_dx = (-B + sqrtDisc) / (2 * A);
                        const t2_dx = (-B - sqrtDisc) / (2 * A);
                        if (t1_dx < -TOLERANCE && t2_dx < -TOLERANCE) throw new Error("Negative time calculated.");
                        t_flight = Math.max(t1_dx, t2_dx);
                        if (t_flight < -TOLERANCE) throw new Error("No positive time solution.");
                        t_flight = Math.max(0, t_flight);
                        finalDx = finalVi * Math.cos(finalAngleRad) * t_flight;
                        break;
                    case "dy":
                        if (inputs.vi === null || angleRad === null || inputs.dx === null) throw new Error("Inputs V<sub>i</sub>, &theta;, and &Delta;x are required.");
                        finalVi = inputs.vi;
                        finalAngleRad = angleRad;
                        finalDx = inputs.dx;
                        if (finalVi <= 0) throw new Error("Initial velocity must be positive.");
                        const Vix_calc_dy = finalVi * Math.cos(finalAngleRad);
                        if (Math.abs(Vix_calc_dy) < TOLERANCE) {
                            if (Math.abs(finalDx) > TOLERANCE) throw new Error("For vertical launch, horizontal displacement must be zero.");
                            throw new Error("Cannot calculate &Delta;y without time for vertical launch.");
                        }
                        t_flight = finalDx / Vix_calc_dy;
                        if (t_flight < -TOLERANCE) throw new Error("Negative time calculated.");
                        t_flight = Math.max(0, t_flight);
                        finalDy = finalVi * Math.sin(finalAngleRad) * t_flight - 0.5 * g * t_flight * t_flight;
                        break;
                    case "vi":
                        if (angleRad === null || inputs.dx === null || inputs.dy === null) throw new Error("Inputs &theta;, &Delta;x, and &Delta;y are required.");
                        finalAngleRad = angleRad;
                        finalDx = inputs.dx;
                        finalDy = inputs.dy;
                        const cosTheta = Math.cos(finalAngleRad);
                        const sinTheta = Math.sin(finalAngleRad);
                        if (Math.abs(cosTheta) < TOLERANCE) {
                             if (Math.abs(finalDx) > TOLERANCE) throw new Error("For vertical launch, dx must be zero.");
                             throw new Error("Cannot calculate V<sub>i</sub> for vertical launch without time.");
                        }
                        const tanTheta = sinTheta / cosTheta;
                        const term1 = tanTheta * finalDx - finalDy;
                        const numerator = g * finalDx * finalDx;
                        const denominator = 2 * cosTheta * cosTheta * term1;
                        if (Math.abs(denominator) < TOLERANCE) {
                             if (Math.abs(term1) < TOLERANCE) {
                                  throw new Error("Infinite speed required.");
                             } else {
                                  throw new Error("Internal error calculating V<sub>i</sub>.");
                             }
                        }
                        if (numerator / denominator < -TOLERANCE) {
                            throw new Error("Negative square encountered in V<sub>i</sub> calculation.");
                        }
                        const Vi_squared = Math.max(0, numerator / denominator);
                        finalVi = Math.sqrt(Vi_squared);
                        const Vix_calc_vi = finalVi * cosTheta;
                        if (Math.abs(Vix_calc_vi) < TOLERANCE) {
                             if (Math.abs(finalDx) > TOLERANCE) throw new Error("Internal error: Vix is zero.");
                             throw new Error("Cannot determine time for vertical launch without time.");
                        }
                        t_flight = finalDx / Vix_calc_vi;
                        if (t_flight < -TOLERANCE) throw new Error("Negative time calculated.");
                        t_flight = Math.max(0, t_flight);
                        break;
                    case "angle":
                        if (inputs.vi === null || inputs.dx === null || inputs.dy === null) throw new Error("Inputs V<sub>i</sub>, &Delta;x, and &Delta;y are required.");
                        finalVi = inputs.vi;
                        finalDx = inputs.dx;
                        finalDy = inputs.dy;
                        if (finalVi <= 0) throw new Error("Initial velocity must be positive.");
                        if (Math.abs(finalDx) < TOLERANCE) {
                            const A_vert = 0.5 * g;
                            const B_vert = -finalVi;
                            const C_vert = finalDy;
                            const disc_vert = B_vert * B_vert - 4 * A_vert * C_vert;
                            if (disc_vert < -TOLERANCE) throw new Error("Target &Delta;y unreachable for vertical launch.");
                            const sqrtDisc_vert = Math.sqrt(Math.max(0, disc_vert));
                            const t1_vert = (-B_vert + sqrtDisc_vert) / (2 * A_vert);
                            const t2_vert = (-B_vert - sqrtDisc_vert) / (2 * A_vert);
                            if (t1_vert < -TOLERANCE && t2_vert < -TOLERANCE) throw new Error("No positive time for vertical launch.");
                            t_flight = Math.max(t1_vert, t2_vert);
                            if (t_flight < -TOLERANCE) throw new Error("No positive time found.");
                            t_flight = Math.max(0, t_flight);
                            finalAngleRad = Math.PI / 2;
                        } else {
                            const A_angle = (g * finalDx * finalDx) / (2 * finalVi * finalVi);
                            const B_angle = -finalDx;
                            const C_angle = finalDy + A_angle;
                            if (Math.abs(A_angle) < TOLERANCE) {
                                if (Math.abs(B_angle) < TOLERANCE) {
                                     throw new Error("Internal error: dx=0 case missed.");
                                }
                                const tan_theta = C_angle / (-B_angle);
                                finalAngleRad = Math.atan(tan_theta);
                            } else {
                                const disc_angle = B_angle * B_angle - 4 * A_angle * C_angle;
                                if (disc_angle < -TOLERANCE) throw new Error("No real launch angle solution.");
                                const sqrtDisc_angle = Math.sqrt(Math.max(0, disc_angle));
                                tan1 = (-B_angle + sqrtDisc_angle) / (2 * A_angle);
                                const tan2 = (-B_angle - sqrtDisc_angle) / (2 * A_angle);
                                angle1 = Math.atan(tan1);
                                angle2 = Math.atan(tan2);
                                finalAngleRad = angle2;
                            }
                            const Vix_calc_ang = finalVi * Math.cos(finalAngleRad);
                            if (Math.abs(Vix_calc_ang) < TOLERANCE) throw new Error("Internal error: Vix is zero.");
                            t_flight = finalDx / Vix_calc_ang;
                            if (t_flight < -TOLERANCE) throw new Error("Negative time calculated.");
                            t_flight = Math.max(0, t_flight);
                        }
                        break;
                    default:
                        throw new Error("Unexpected error: Could not determine missing variable.");
                }

                if (!isFinite(t_flight) || t_flight < -TOLERANCE) {
                    throw new Error("Invalid time of flight calculated.");
                }
                t_flight = Math.max(0, t_flight);
                const finalAngleDeg = finalAngleRad * 180 / Math.PI;
                const Vix = finalVi * Math.cos(finalAngleRad);
                const Viy = finalVi * Math.sin(finalAngleRad);
                globalVix = Vix;
                globalViy = Viy;
                const t_peak = (Math.abs(g) > TOLERANCE && Viy > TOLERANCE) ? Viy / g : 0;
                const h_max = (t_peak > 0) ? (Viy * t_peak - 0.5 * g * t_peak * t_peak) : 0;
                const Vfx = Vix;
                const Vfy = Viy - g * t_flight;
                const Vf_mag = Math.sqrt(Vfx * Vfx + Vfy * Vfy);
                const Vf_angle_rad = Math.atan2(Vfy, Vfx);
                const Vf_angle_deg = Vf_angle_rad * 180 / Math.PI;

                let resultHTML = `<div class="result">`;
                resultHTML += `<div class="group-title">Calculated Result</div>`;
                switch (missingVar) {
                    case "vi": resultHTML += formatResultLine("Initial Velocity, V<sub>i</sub>", finalVi, "m/s"); break;
                    case "angle": resultHTML += formatResultLine("Launch Angle, &theta;", finalAngleDeg, "°"); break;
                    case "dy": resultHTML += formatResultLine("Vertical Displacement, &Delta;y", finalDy, "m"); break;
                    case "dx": resultHTML += formatResultLine("Horizontal Displacement, &Delta;x", finalDx, "m"); break;
                }
                if (missingVar === 'angle' && angle1 !== undefined && angle2 !== undefined && Math.abs(angle1 - angle2) > TOLERANCE) {
                     const chosenAngle = finalAngleRad;
                     const otherAngle = (Math.abs(chosenAngle - angle1) < TOLERANCE) ? angle2 : angle1;
                     resultHTML += `<p style="font-size: 0.9em; color: var(--label-color);"><em>Note: A second launch angle solution exists: ${(otherAngle * 180 / Math.PI).toFixed(2)}°</em></p>`;
                }
                resultHTML += `<div class="group-title">Trajectory Summary</div>`;
                resultHTML += formatResultLine("Time of Flight, t", t_flight, "s");
                resultHTML += formatResultLine("Max Height (above launch)", h_max, "m");
                resultHTML += formatResultLine("Time to Max Height", t_peak, "s");
                resultHTML += `<div class="group-title">Initial Conditions</div>`;
                resultHTML += formatResultLine("Initial Velocity, V<sub>i</sub>", finalVi, "m/s");
                resultHTML += formatResultLine("Launch Angle, &theta;", finalAngleDeg, "°");
                resultHTML += formatResultLine("Initial Horizontal Vel., V<sub>ix</sub>", Vix, "m/s");
                resultHTML += formatResultLine("Initial Vertical Vel., V<sub>iy</sub>", Viy, "m/s");
                resultHTML += `<div class="group-title">Final State (at t = ${t_flight.toFixed(2)}s)</div>`;
                resultHTML += formatResultLine("Final Horizontal Disp., &Delta;x", finalDx, "m");
                resultHTML += formatResultLine("Final Vertical Disp., &Delta;y", finalDy, "m");
                resultHTML += formatResultLine("Final Velocity Mag., V<sub>f</sub>", Vf_mag, "m/s");
                resultHTML += formatResultLine("Final Velocity Angle, &phi;", Vf_angle_deg, "°");
                resultHTML += formatResultLine("Final Horizontal Vel., V<sub>fx</sub>", Vfx, "m/s");
                resultHTML += formatResultLine("Final Vertical Vel., V<sub>fy</sub>", Vfy, "m/s");
                if (timeOptional !== null && isFinite(timeOptional) && timeOptional >= 0) {
                    const t_opt = Math.min(timeOptional, t_flight);
                    const t_opt_calc = timeOptional;
                    const dx_opt = Vix * t_opt_calc;
                    const dy_opt = Viy * t_opt_calc - 0.5 * g * t_opt_calc * t_opt_calc;
                    const vx_opt = Vix;
                    const vy_opt = Viy - g * t_opt_calc;
                    const speed_opt = Math.sqrt(vx_opt * vx_opt + vy_opt * vy_opt);
                    const angle_opt = Math.atan2(vy_opt, vx_opt) * 180 / Math.PI;
                    resultHTML += `<div class="group-title">State at Optional Time (t = ${t_opt_calc.toFixed(2)}s)</div>`;
                    resultHTML += formatResultLine("Horizontal Disp., &Delta;x", dx_opt, "m");
                    resultHTML += formatResultLine("Vertical Disp., &Delta;y", dy_opt, "m");
                    resultHTML += formatResultLine("Horizontal Vel., V<sub>x</sub>", vx_opt, "m/s");
                    resultHTML += formatResultLine("Vertical Vel., V<sub>y</sub>", vy_opt, "m/s");
                    resultHTML += formatResultLine("Speed", speed_opt, "m/s");
                    resultHTML += formatResultLine("Velocity Angle", angle_opt, "°");
                }
                resultHTML += `</div>`;
                showResult(resultHTML);
                prepareAndDrawTrajectory(Vix, Viy, t_flight, g, dy);
            } catch (e) {
                console.error("Basic Mode Calc Error:", e);
                showError("2D Mode Calculation Error: " + e.message);
                resetAnimation();
            }
        }

        // --- 2D Projectile Motion (Design Mode) Calculation ---
        function calculateDesignMode(g) {
            globalG = g;
            const dx_target = getFloatValue("dxDesign");
            const dy_target = getFloatValue("dyDesign");
            const landingAngleDeg = getFloatValue("landingAngle");
            if (isNaN(dx_target) || isNaN(dy_target) || isNaN(landingAngleDeg)) {
                showNote("Design Mode: Please fill in target &Delta;x, &Delta;y, and desired landing angle &phi;.");
                resetAnimation();
                return;
            }
            if (Math.abs(g) < TOLERANCE) {
                showError("Design mode requires non-zero gravitational acceleration (g).");
                resetAnimation();
                return;
            }
            if (Math.abs(dx_target) < TOLERANCE) {
                showError("Design mode requires a non-zero Horizontal Displacement (&Delta;x).");
                resetAnimation();
                return;
            }
            try {
                const phi_rad = landingAngleDeg * Math.PI / 180;
                const tan_phi = Math.tan(phi_rad);
                const tan_theta = (2 * dy_target / dx_target) - tan_phi;
                const theta_rad = Math.atan(tan_theta);
                const theta_deg = theta_rad * 180 / Math.PI;
                const denominator_VixSq = tan_theta - tan_phi;
                let finalVi;
                if (Math.abs(denominator_VixSq) < TOLERANCE) {
                    if (Math.abs(dy_target) > TOLERANCE) {
                        throw new Error("Calculation error: Launch angle approx equals landing angle, but target &Delta;y is not zero.");
                    }
                    const sin2theta = Math.sin(2 * theta_rad);
                    if (Math.abs(sin2theta) < TOLERANCE) throw new Error("Cannot calculate V<sub>i</sub>: Launch angle is near 0° or 90°.");
                    const Vi_sq = g * dx_target / sin2theta;
                    if (Vi_sq < -TOLERANCE) throw new Error("Calculation resulted in negative V<sub>i</sub>².");
                    finalVi = Math.sqrt(Math.max(0, Vi_sq));
                } else {
                    const Vix_sq = g * dx_target / denominator_VixSq;
                    if (Vix_sq < -TOLERANCE) {
                        throw new Error("Calculation resulted in negative V<sub>ix</sub>².");
                    }
                    const Vix = Math.sqrt(Math.max(0, Vix_sq));
                    const cosTheta = Math.cos(theta_rad);
                    if (Math.abs(cosTheta) < TOLERANCE) throw new Error("Calculated launch angle is vertical.");
                    finalVi = Vix / cosTheta;
                }
                const finalAngleRad = theta_rad;
                const finalAngleDeg = theta_deg;
                if (!isFinite(finalVi) || finalVi <= 0) {
                    throw new Error("Calculated Initial Velocity (V<sub>i</sub>) is invalid.");
                }
                const Vix = finalVi * Math.cos(finalAngleRad);
                const Viy = finalVi * Math.sin(finalAngleRad);
                globalVix = Vix;
                globalViy = Viy;
                if (Math.abs(Vix) < TOLERANCE) throw new Error("Horizontal velocity Vix is near zero.");
                const t_flight = dx_target / Vix;
                if (t_flight < -TOLERANCE) throw new Error("Negative time of flight calculated.");
                const t_flight_nonNeg = Math.max(0, t_flight);
                const t_peak = (Math.abs(g) > TOLERANCE && Viy > TOLERANCE) ? Viy / g : 0;
                const h_max = (t_peak > 0) ? (Viy * t_peak - 0.5 * g * t_peak * t_peak) : 0;
                const Vfx_check = Vix;
                const Vfy_check = Viy - g * t_flight_nonNeg;
                const Vf_mag_check = Math.sqrt(Vfx_check * Vfx_check + Vfy_check * Vfy_check);
                const Vf_angle_rad_check = Math.atan2(Vfy_check, Vfx_check);
                const Vf_angle_deg_check = Vf_angle_rad_check * 180 / Math.PI;
                const dx_check = Vix * t_flight_nonNeg;
                const dy_check = Viy * t_flight_nonNeg - 0.5 * g * t_flight_nonNeg * t_flight_nonNeg;
                let resultHTML = `<div class="result">`;
                resultHTML += `<div class="group-title">Design Mode Results: Required Launch</div>`;
                resultHTML += formatResultLine("Launch Angle, &theta;", finalAngleDeg, "°");
                resultHTML += formatResultLine("Initial Velocity, V<sub>i</sub>", finalVi, "m/s");
                resultHTML += `<div class="group-title">Resulting Trajectory</div>`;
                resultHTML += formatResultLine("Time of Flight, t", t_flight_nonNeg, "s");
                resultHTML += formatResultLine("Max Height (above launch)", h_max, "m");
                resultHTML += formatResultLine("Time to Max Height", t_peak, "s");
                resultHTML += `<div class="group-title">Initial Velocity Components</div>`;
                resultHTML += formatResultLine("Initial Horizontal Vel., V<sub>ix</sub>", Vix, "m/s");
                resultHTML += formatResultLine("Initial Vertical Vel., V<sub>iy</sub>", Viy, "m/s");
                resultHTML += `<div class="group-title">Achieved Final State (Verification)</div>`;
                resultHTML += formatResultLine("Final Horizontal Disp., &Delta;x", dx_check, "m");
                resultHTML += formatResultLine("Final Vertical Disp., &Delta;y", dy_check, "m");
                resultHTML += formatResultLine("Final Velocity Mag., V<sub>f</sub>", Vf_mag_check, "m/s");
                resultHTML += formatResultLine("Final Velocity Angle, &phi;", Vf_angle_deg_check, "°");
                resultHTML += formatResultLine("Final Horizontal Vel., V<sub>fx</sub>", Vfx_check, "m/s");
                resultHTML += formatResultLine("Final Vertical Vel., V<sub>fy</sub>", Vfy_check, "m/s");
                resultHTML += `</div>`;
                showResult(resultHTML);
                prepareAndDrawTrajectory(Vix, Viy, t_flight_nonNeg, g, dy_target);
            } catch (e) {
                console.error("Design Mode Calc Error:", e);
                showError("Design Mode Calculation Error: " + e.message);
                resetAnimation();
            }
        }

        // --- Trajectory Data Generation and Drawing Setup ---
        function prepareAndDrawTrajectory(Vix, Viy, t_flight, g, y_end) {
            if (!trajectoryCanvas) return;
            globalPoints = [];
            global_t_flight = Math.max(0, t_flight);
            // If the final displacement (y_end) is negative, shift the trajectory upward
            let verticalShift = (y_end < 0) ? -y_end : 0;
            // Save the vertical shift globally so the ball and peak label use it
            globalVerticalShift = verticalShift;
            const numPoints = 100;
            const dt = (global_t_flight > TOLERANCE) ? global_t_flight / numPoints : 0;
            for (let i = 0; i <= numPoints; i++) {
                const t = i * dt;
                const x = Vix * t;
                // Apply vertical shift to ensure the landing point is drawn at y=0
                const y = Viy * t - 0.5 * g * t * t + verticalShift;
                globalPoints.push({ x, y, t });
            }
            if (globalPoints.length === 0 || Math.abs(globalPoints[globalPoints.length - 1].t - global_t_flight) > TOLERANCE) {
                const x_final = Vix * global_t_flight;
                const y_final = Viy * global_t_flight - 0.5 * g * global_t_flight * global_t_flight + verticalShift;
                if (globalPoints.length > 0) {
                    globalPoints[globalPoints.length - 1] = { x: x_final, y: y_final, t: global_t_flight };
                } else {
                    globalPoints.push({ x: x_final, y: y_final, t: global_t_flight });
                }
            }
            if (globalPoints.length === 0) {
                console.warn("No trajectory points generated.");
                resetAnimation();
                return;
            }
            const xs = globalPoints.map(p => p.x);
            const ys = globalPoints.map(p => p.y);
            const minX = Math.min(0, ...xs);
            const maxX = Math.max(0, ...xs);
            const minY = Math.min(0, ...ys);
            const maxY = Math.max(0, ...ys);
            const marginFactor = 0.15;
            const canvasWidth = trajectoryCanvas.width;
            const canvasHeight = trajectoryCanvas.height;
            const availableWidth = canvasWidth * (1 - marginFactor * 2);
            const availableHeight = canvasHeight * (1 - marginFactor * 2);
            const rangeX = (maxX - minX);
            const rangeY = (maxY - minY);
            const scaleX = (Math.abs(rangeX) < TOLERANCE) ? 1 : availableWidth / rangeX;
            const scaleY = (Math.abs(rangeY) < TOLERANCE) ? 1 : availableHeight / rangeY;
            globalScale = Math.min(scaleX, scaleY);
            globalScale = Math.max(1e-6, globalScale);
            globalScale = Math.min(1e6, globalScale);
            const trajWidthScaled = rangeX * globalScale;
            globalOffsetX = (canvasWidth - trajWidthScaled) / 2 - minX * globalScale;
            // Set globalOffsetY so that the lowest point appears near the bottom margin
            globalOffsetY = canvasHeight * (1 - marginFactor) + minY * globalScale;
            resetAnimation();
        }

        // --- Canvas Drawing Functions ---
        function drawStaticTrajectory() {
            const ctx = trajectoryCanvas.getContext("2d");
            if (!ctx || globalPoints.length === 0) return;
            ctx.clearRect(0, 0, trajectoryCanvas.width, trajectoryCanvas.height);
            // Draw axes with a hardcoded neutral dark gray color
            ctx.strokeStyle = "#555555";
            ctx.lineWidth = 1;
            const originY_canvas = globalOffsetY - (0 * globalScale);
            ctx.beginPath();
            ctx.moveTo(0, originY_canvas);
            ctx.lineTo(trajectoryCanvas.width, originY_canvas);
            ctx.stroke();
            const originX_canvas = globalOffsetX + (0 * globalScale);
            ctx.beginPath();
            ctx.moveTo(originX_canvas, 0);
            ctx.lineTo(originX_canvas, trajectoryCanvas.height);
            ctx.stroke();
            // Draw the trajectory path using a hardcoded blue color (#1e90ff)
            ctx.beginPath();
            globalPoints.forEach((pt, i) => {
                const canvasX = globalOffsetX + pt.x * globalScale;
                const canvasY = globalOffsetY - pt.y * globalScale;
                if (i === 0) {
                    ctx.moveTo(canvasX, canvasY);
                } else {
                    ctx.lineTo(canvasX, canvasY);
                }
            });
            ctx.strokeStyle = "#1e90ff";
            ctx.lineWidth = 2;
            ctx.stroke();
            // Draw key markers
            const startPoint = globalPoints[0];
            const endPoint = globalPoints[globalPoints.length - 1];
            let peakPoint = startPoint;
            if (Math.abs(globalG) > TOLERANCE && globalViy > TOLERANCE) {
                const t_peak = globalViy / globalG;
                if (t_peak > 0 && t_peak <= global_t_flight + TOLERANCE) {
                    peakPoint = {
                        x: globalVix * t_peak,
                        // Apply the vertical shift to the peak label calculation
                        y: globalViy * t_peak - 0.5 * globalG * t_peak * t_peak + globalVerticalShift,
                        t: t_peak
                    };
                } else {
                    peakPoint = globalPoints.reduce((max, p) => p.y > max.y ? p : max, startPoint);
                }
            } else {
                peakPoint = globalPoints.reduce((max, p) => p.y > max.y ? p : max, startPoint);
            }
            drawMarker(ctx, startPoint, "green", "Start");
            if (peakPoint.y > Math.max(startPoint.y, endPoint.y) + (0.01 / globalScale)) {
                drawMarker(ctx, peakPoint, "orange", "Peak");
            }
            drawMarker(ctx, endPoint, "red", "Landing");
        }

        function drawMarker(ctx, pt, color, label) {
            if (!pt) return;
            const cx = globalOffsetX + pt.x * globalScale;
            const cy = globalOffsetY - pt.y * globalScale;
            ctx.beginPath();
            ctx.arc(cx, cy, 5, 0, 2 * Math.PI);
            ctx.fillStyle = color;
            ctx.fill();
            ctx.strokeStyle = "rgba(0,0,0,0.5)";
            ctx.lineWidth = 1;
            ctx.stroke();
            ctx.fillStyle = "var(--marker-text-color)";
            ctx.font = "11px Arial";
            ctx.textAlign = "left";
            ctx.textBaseline = "bottom";
            let labelX = cx + 8;
            let labelY = cy - 5;
            if (cx > trajectoryCanvas.width - 50) {
                ctx.textAlign = "right";
                labelX = cx - 8;
            }
            if (cy < 20) {
                 labelY = cy + 15;
            }
            ctx.fillText(label, labelX, labelY);
        }

        function drawProjectile(ctx, t_current) {
            if (!isFinite(globalVix) || !isFinite(globalViy) || !isFinite(globalG)) return;
            const x_current = globalVix * t_current;
            // Add the global vertical shift so the projectile follows the shifted trajectory
            const y_current = globalViy * t_current - 0.5 * globalG * t_current * t_current + globalVerticalShift;
            const ballX = globalOffsetX + x_current * globalScale;
            const ballY = globalOffsetY - y_current * globalScale;
            ctx.beginPath();
            ctx.arc(ballX, ballY, 6, 0, 2 * Math.PI);
            ctx.fillStyle = "blue";
            ctx.fill();
            ctx.strokeStyle = "white";
            ctx.lineWidth = 1;
            ctx.stroke();
        }

        // --- Animation & Slider Control ---
        function updateAnimationFrame() {
            const ctx = trajectoryCanvas.getContext("2d");
            if (!ctx || !isFinite(global_t_flight)) return;
            const sliderValue = parseFloat(trajectorySlider.value);
            const t_current = (global_t_flight > TOLERANCE) ? (sliderValue / 100) * global_t_flight : 0;
            drawStaticTrajectory();
            drawProjectile(ctx, t_current);
            updateStateDisplay(t_current);
        }

        function startAutoAnimation() {
            if (autoAnimating) return;
            if (!isFinite(global_t_flight) || global_t_flight <= 0) return;
            autoAnimating = true;
            animationStartTime = null;
            startStopButton.textContent = "Stop";
            function animateFrame(timestamp) {
                if (!autoAnimating) return;
                if (!animationStartTime) {
                    animationStartTime = timestamp - (pausedProgress * ANIMATION_DURATION);
                }
                const elapsed = timestamp - animationStartTime;
                let progress = Math.min(elapsed / ANIMATION_DURATION, 1);
                trajectorySlider.value = progress * 100;
                updateAnimationFrame();
                if (progress < 1) {
                    animationFrameId = requestAnimationFrame(animateFrame);
                } else {
                    autoAnimating = false;
                    startStopButton.textContent = "Start";
                    pausedProgress = 0;
                    trajectorySlider.value = 100;
                    updateAnimationFrame();
                }
            }
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            animationFrameId = requestAnimationFrame(animateFrame);
        }

        function toggleAnimation() {
            if (autoAnimating) {
                autoAnimating = false;
                if (animationFrameId) cancelAnimationFrame(animationFrameId);
                pausedProgress = parseFloat(trajectorySlider.value) / 100;
                startStopButton.textContent = "Start";
            } else {
                if (parseFloat(trajectorySlider.value) >= 99.9) {
                     pausedProgress = 0;
                     trajectorySlider.value = 0;
                } else {
                      pausedProgress = parseFloat(trajectorySlider.value) / 100;
                }
                startAutoAnimation();
            }
        }

        function resetAnimation() {
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            autoAnimating = false;
            pausedProgress = 0;
            trajectorySlider.value = 0;
            startStopButton.textContent = "Start";
            if (globalPoints && globalPoints.length > 0) {
                 updateAnimationFrame();
            } else {
                 const ctx = trajectoryCanvas.getContext("2d");
                 if (ctx) ctx.clearRect(0, 0, trajectoryCanvas.width, trajectoryCanvas.height);
                 updateStateDisplay(0);
            }
        }

        function handleSliderInput() {
            if (autoAnimating) {
                autoAnimating = false;
                if (animationFrameId) cancelAnimationFrame(animationFrameId);
                startStopButton.textContent = "Start";
            }
            updateAnimationFrame();
        }

        function handleSliderChange() {
            pausedProgress = parseFloat(trajectorySlider.value) / 100;
            updateAnimationFrame();
        }

        // --- State Display Update ---
        function updateStateDisplay(t) {
            if (typeof globalVix !== 'number' || typeof globalViy !== 'number' || !isFinite(globalVix) || !isFinite(globalViy) || typeof globalG !== 'number' || !isFinite(globalG)) {
                 stateDisplayValues.innerHTML = `
                     <p><strong>Time:</strong> <span>-- s</span></p>
                     <p><strong>&Delta;x:</strong> <span>-- m</span></p>
                     <p><strong>&Delta;y:</strong> <span>-- m</span></p>
                     <p><strong>V<sub>x</sub>:</strong> <span>-- m/s</span></p>
                     <p><strong>V<sub>y</sub>:</strong> <span>-- m/s</span></p>
                     <p><strong>Speed:</strong> <span>-- m/s</span></p>
                     <p><strong>Angle:</strong> <span>-- °</span></p>
                 `;
                 return;
            }
            const display_t = Math.max(0, t);
            const dx = globalVix * display_t;
            const dy = globalViy * display_t - 0.5 * globalG * display_t * display_t;
            const vx = globalVix;
            const vy = globalViy - globalG * display_t;
            const speed = Math.sqrt(vx * vx + vy * vy);
            const angle = Math.atan2(vy, vx) * 180 / Math.PI;
            stateDisplayValues.innerHTML = `
                <p><strong>Time:</strong> <span>${display_t.toFixed(2)} s</span></p>
                <p><strong>&Delta;x:</strong> <span>${dx.toFixed(2)} m</span></p>
                <p><strong>&Delta;y:</strong> <span>${dy.toFixed(2)} m</span></p>
                <p><strong>V<sub>x</sub>:</strong> <span>${vx.toFixed(2)} m/s</span></p>
                <p><strong>V<sub>y</sub>:</strong> <span>${vy.toFixed(2)} m/s</span></p>
                <p><strong>Speed:</strong> <span>${speed.toFixed(2)} m/s</span></p>
                <p><strong>Angle:</strong> <span>${angle.toFixed(2)} °</span></p>
            `;
        }

        // --- Main Calculation Dispatcher ---
        function calculate() {
            const mode = getSelectedMode();
            try {
                if (mode === "1d") {
                     clearMessages();
                     showNote("1D Mode: Fill in <strong>exactly three</strong> fields.");
                    calculate1DMode();
                } else {
                    const accInput = getFloatValue("acceleration");
                    const g = (isFinite(accInput) && accInput > 0) ? accInput : G_DEFAULT;
                     if (!isFinite(accInput) || accInput <= 0) {
                         document.getElementById("acceleration").value = G_DEFAULT;
                     }
                    if (mode === "basic") {
                         clearMessages();
                         showNote("2D Mode: Fill in <strong>exactly three</strong> of V<sub>i</sub>, &Delta;x, &Delta;y, &theta;.");
                        calculateBasicMode(g);
                    } else if (mode === "design") {
                         clearMessages();
                         showNote("Design Mode: Fill in target &Delta;x, &Delta;y, and landing angle &phi;.");
                        calculateDesignMode(g);
                    }
                }
            } catch (err) {
                console.error("Unhandled Calculation Error:", err);
                showError("Calculation Error: " + err.message);
                resetAnimation();
            }
        }
    </script>
</body>
</html>
