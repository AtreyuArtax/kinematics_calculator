<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Kinematics & Projectile Motion Calculator</title>
    <meta name="theme-color" content="#0056b3" />
    <link rel="manifest" href="./manifest.webmanifest" />
    <link rel="icon" href="./icons/icon-192.png" />
    <link rel="icon" href="./icons/icon-512.png" sizes="512x512" />
    <link rel="icon" href="./icons/icon-192.svg" sizes="192x192" />
    <link rel="icon" href="./icons/icon-512.svg" sizes="512x512" />
  <style>
    /* --- Light Mode Variables (Default) --- */
    :root {
      --primary-color: #0056b3;
      --secondary-color: #f8f9fa; /* Body background */
      --container-bg: #ffffff; /* Container background */
      --text-color: #212529; /* Main text */
      --label-color: #495057; /* Labels */
      --border-color: #dee2e6; /* Borders */
      --input-bg: #ffffff; /* Input background */
      --input-text: #495057; /* Input text */
      --input-focus-border: #86b7fe; /* Input focus border */
      --input-focus-shadow: rgba(0, 123, 255, 0.25); /* Input focus shadow */
      --success-bg: #d1e7dd;
      --success-text: #0f5132;
      --success-border: #badbcc;
      --error-bg: #f8d7da;
      --error-text: #842029;
      --error-border: #f5c2c7;
      --note-bg: #fff3cd;
      --note-text: #664d03;
      --note-border: #ffecb5;
      --shadow-color: rgba(0, 0, 0, 0.1);
      --button-bg: #ffffff;
      --button-hover-bg: #e9ecef;
      --button-border: #ced4da;
      --radio-checked-bg: #e7f1ff;
      --radio-checked-border: var(--primary-color);
      --canvas-bg: #ffffff;
      /* We now hardcode the trajectory colour to blue in the drawing functions */
      --trajectory-color: #aaccee;
      --marker-text-color: #000000;
      --state-display-bg: #ffffff;
      --state-display-border: var(--border-color);
      --state-display-text: var(--text-color);
      --axis-color: rgba(128, 128, 128, 0.5);
      --border-radius: 8px;
      --spacing-unit: 1rem;
    }

    /* --- Dark Mode Variables --- */
    @media (prefers-color-scheme: dark) {
      :root {
        --primary-color: #58a6ff;
        --secondary-color: #0d1117;
        --container-bg: #161b22;
        --text-color: #c9d1d9;
        --label-color: #8b949e;
        --border-color: #30363d;
        --input-bg: #0d1117;
        --input-text: #c9d1d9;
        --input-focus-border: #58a6ff;
        --input-focus-shadow: rgba(88, 166, 255, 0.25);
        --success-bg: #0f2d1f;
        --success-text: #56d364;
        --success-border: #1a472a;
        --error-bg: #35191c;
        --error-text: #f87171;
        --error-border: #58292d;
        --note-bg: #3a2c0f;
        --note-text: #eac54f;
        --note-border: #6e551a;
        --shadow-color: rgba(0, 0, 0, 0.4);
        --button-bg: #21262d;
        --button-hover-bg: #30363d;
        --button-border: #30363d;
        --radio-checked-bg: #1f6feb;
        --radio-checked-border: var(--primary-color);
        --canvas-bg: #1a1f27;
        --trajectory-color: #58a6ff;
        --marker-text-color: #c9d1d9;
        --state-display-bg: #161b22;
        --state-display-border: var(--border-color);
        --state-display-text: var(--text-color);
        --axis-color: rgba(160, 160, 160, 0.4);
      }
    }

    /* --- Base & Layout Styles --- */
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    html {
      scroll-behavior: smooth;
      font-size: 16px;
      color-scheme: light dark;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji";
      background-color: var(--secondary-color);
      color: var(--text-color);
      line-height: 1.6;
      padding: var(--spacing-unit);
      display: flex;
      justify-content: center;
      align-items: flex-start;
      min-height: 100vh;
      transition: background-color 0.3s ease, color 0.3s ease;
    }

    .wrapper {
      width: 100%;
      max-width: 1200px;
      display: flex;
      flex-direction: column;
      gap: 2rem;
    }

    .top-container {
      display: flex;
      flex-direction: column;
      gap: 2rem;
    }

    @media (min-width: 900px) {
      .top-container {
        flex-direction: row;
      }
    }

    /* Optimizer-specific layout: inputs top-left, sticky graph top-right, results bottom */
    .wrapper.optimizer-mode {
      display: grid;
      grid-template-columns: 500px 600px;
      grid-template-rows: auto auto;
      gap: 1rem;
      max-width: none;
      min-height: 100vh;
      align-items: start;
      justify-content: center;
    }

    .wrapper.optimizer-mode .top-container {
      grid-column: 1;
      grid-row: 1;
      display: block;
      margin: 0;
    }

    .wrapper.optimizer-mode #trajectoryPanel {
      grid-column: 2;
      grid-row: 1;
      position: sticky;
      top: 1rem;
      height: fit-content;
      max-height: calc(100vh - 2rem);
      overflow-y: auto;
      margin: 0;
      align-self: start;
    }

    .wrapper.optimizer-mode #optimizerResultContainer {
      grid-column: 1;
      grid-row: 2;
      margin-top: 2rem;
    }

    .wrapper.optimizer-mode #resultContainer {
      display: none;
    }

    .wrapper.optimizer-mode #stateDisplayContainer {
      display: none;
    }

    /* Collapsible display options in top-right corner of canvas */
    .wrapper.optimizer-mode #optimizerDisplayOptions {
      position: absolute;
      top: 10px;
      right: 10px;
      background: var(--container-bg);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      box-shadow: 0 2px 8px var(--shadow-color);
      z-index: 10;
      min-width: 200px;
    }

    .wrapper.optimizer-mode #trajectoryContainer {
      position: relative;
    }

    .display-options-header {
      padding: 8px 12px;
      background: var(--header-bg, #f5f5f5);
      border-bottom: 1px solid var(--border-color);
      border-radius: 8px 8px 0 0;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-weight: 500;
      font-size: 0.9em;
      user-select: none;
    }

    .display-options-content {
      padding: 12px;
      display: none;
    }

    .display-options-content.expanded {
      display: block;
    }

    .display-options-toggle {
      transition: transform 0.2s ease;
      font-size: 0.8em;
    }

    .display-options-toggle.expanded {
      transform: rotate(180deg);
    }

    .wrapper.optimizer-mode #optimizerDisplayOptions .form-group {
      margin-bottom: 8px;
    }

    .wrapper.optimizer-mode #optimizerDisplayOptions .form-group:last-child {
      margin-bottom: 0;
    }

    .wrapper.optimizer-mode #optimizerDisplayOptions label {
      font-size: 0.85em;
      margin: 0;
    }

    @media (max-width: 1200px) {
      .wrapper.optimizer-mode {
        grid-template-columns: 1fr;
        grid-template-rows: auto auto auto;
      }
      
      .wrapper.optimizer-mode .top-container {
        grid-column: 1;
        grid-row: 1;
      }
      
      .wrapper.optimizer-mode #trajectoryPanel {
        grid-column: 1;
        grid-row: 2;
        position: relative;
        top: auto;
        height: auto;
        max-height: none;
        overflow-y: visible;
      }
      
      .wrapper.optimizer-mode #optimizerResultContainer {
        grid-column: 1;
        grid-row: 3;
        margin-top: 1rem;
      }
    }

    .container {
      background-color: var(--container-bg);
      border-radius: var(--border-radius);
      box-shadow: 0 4px 12px var(--shadow-color);
      padding: 2rem;
      flex: 1;
      border: 1px solid var(--border-color);
      transition: background-color 0.3s ease, border-color 0.3s ease;
    }

    h1 {
      font-size: 1.5rem;
      color: var(--primary-color);
      margin-bottom: 0;
    }

    h2 {
      margin-bottom: 1rem;
      color: var(--primary-color);
      font-size: 1.25rem;
      border-bottom: 1px solid var(--border-color);
      padding-bottom: 0.5rem;
    }

    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1rem;
      flex-wrap: wrap;
      gap: 0.75rem;
    }

    .form-group {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      margin-bottom: 0.6rem;
      gap: 0.4rem;
    }

    .form-group label {
      flex: 0 0 250px;
      font-weight: 500;
      color: var(--label-color);
      padding-right: 0.5rem;
    }

    .form-group input[type="number"] {
      flex: 1;
      min-width: 120px;
      padding: 0.5rem 0.65rem;
      border-radius: var(--border-radius);
      border: 1px solid var(--border-color);
      background-color: var(--input-bg);
      color: var(--input-text);
      font-size: 0.95rem;
      transition: box-shadow 0.2s ease, border-color 0.2s ease, background-color 0.3s ease, color 0.3s ease;
    }

    .form-group input[type="number"]:focus {
      outline: none;
      border-color: var(--input-focus-border);
      box-shadow: 0 0 0 3px var(--input-focus-shadow);
    }

    .unit {
      font-size: 0.85rem;
      color: var(--label-color);
      margin-left: 0.25rem;
      opacity: 0.8;
    }

    .modeToggle {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
    }

    .modeToggle input[type="radio"] {
      display: none;
    }

    .modeToggle label {
      padding: 0.5rem 1rem;
      border: 1px solid var(--button-border);
      border-radius: var(--border-radius);
      background-color: var(--button-bg);
      color: var(--text-color);
      cursor: pointer;
      transition: background-color 0.2s ease, border-color 0.2s ease, color 0.2s ease;
      font-weight: 500;
    }

    .modeToggle label:hover {
      background-color: var(--button-hover-bg);
    }

    .modeToggle input[type="radio"]:checked + label {
      background-color: var(--radio-checked-bg);
      border-color: var(--radio-checked-border);
      color: var(--primary-color);
      font-weight: 600;
    }

    @media (prefers-color-scheme: dark) {
      .modeToggle input[type="radio"]:checked + label {
        color: #ffffff;
      }
    }

    .note, .error, .result {
      margin-top: 1rem;
      padding: 0.75rem 1rem;
      border-radius: var(--border-radius);
      border-width: 1px;
      border-style: solid;
      transition: background-color 0.3s ease, border-color 0.3s ease, color 0.3s ease;
    }

    .error {
      background-color: var(--error-bg);
      color: var(--error-text);
      border-color: var(--error-border);
    }

    .result {
      background-color: var(--success-bg);
      color: var(--success-text);
      border-color: var(--success-border);
    }

    .note {
      background-color: var(--note-bg);
      color: var(--note-text);
      border-color: var(--note-border);
      margin-bottom: 0.75rem;
    }

    .result .group-title {
      font-weight: 600;
      font-size: 1.1rem;
      margin-top: 1.5rem;
      margin-bottom: 0.75rem;
      border-bottom: 1px solid var(--border-color);
      padding-bottom: 0.35rem;
      color: var(--primary-color);
    }

    .result .group-title:first-of-type {
      margin-top: 0;
    }

    .result p {
      margin-bottom: 0.6rem;
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
    }

    .result p strong {
      font-weight: 500;
      display: inline-block;
      min-width: 210px;
      color: var(--label-color);
    }

    .result p span:not(.unit) {
      color: var(--text-color);
      font-weight: 400;
    }

    .hidden {
      display: none !important;
    }

    /* --- Trajectory Panel --- */
    #trajectoryPanel {
      margin-top: 2rem;
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
    }

/* --- New Trajectory Panel Inner Layout --- */
#trajectoryPanelInner {
  display: flex;
  gap: 1.5rem;
  align-items: flex-start;
}

/* On small screens, stack the two containers vertically */
@media (max-width: 600px) {
  #trajectoryPanelInner {
    flex-direction: column;
  }
}

/* Container for the trajectory canvas, slider, and buttons */
#trajectoryContainer {
  flex: 2;
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
}

/* Container for the current state display */
#stateDisplayContainer {
  flex: 1 1 0;
  min-width: 0;
}



    /* New container for the main trajectory display */
    #trajectoryMain {
      display: flex;
      gap: 1.5rem;
      flex-wrap: wrap;
      align-items: flex-start;
    }
    
    /* Ensure that on small screens the canvas and state display stack vertically */
    @media (max-width: 600px) {
      #trajectoryMain {
        flex-direction: column;
      }
    }

    #trajectoryCanvas {
     
      border: 1px solid var(--border-color);
      border-radius: var(--border-radius);
      background-color: var(--canvas-bg);
      transition: background-color 0.3s ease, border-color 0.3s ease;
      display: block;
      width: 100%;
	  max-width: 800px;
      height: auto;
      aspect-ratio: 800 / 400;
    }

    #stateDisplay {
      flex: 1 1 200px;
      min-width: 180px;
      border: 1px solid var(--state-display-border);
      border-radius: var(--border-radius);
      background-color: var(--state-display-bg);
      color: var(--state-display-text);
      padding: 1rem;
      font-size: 0.9rem;
      transition: background-color 0.3s ease, border-color 0.3s ease, color 0.3s ease;
    }

    #stateDisplay h3 {
      font-size: 1rem;
      margin-bottom: 0.75rem;
      color: var(--primary-color);
      border-bottom: 1px solid var(--border-color);
      padding-bottom: 0.3rem;
    }

    #stateDisplay p {
      margin-bottom: 0.4rem;
      display: flex;
      justify-content: space-between;
    }

    #stateDisplay p strong {
      color: var(--label-color);
      font-weight: 500;
    }

    /* --- Trajectory Controls (New Container) --- */
    #trajectoryControls {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }
    
    #trajectoryControls .buttonContainer {
      display: flex;
      justify-content: center;
      gap: 0.5rem;
    }
    
    #trajectorySlider {
      width: 100%;
      cursor: pointer;
    }

    #startStopButton, #resetButton {
      padding: 0.6rem 1.2rem;
      font-size: 0.95rem;
      border: 1px solid var(--button-border);
      border-radius: var(--border-radius);
      background-color: var(--button-bg);
      color: var(--text-color);
      cursor: pointer;
      transition: background-color 0.2s ease, border-color 0.2s ease;
      font-weight: 500;
    }

    #startStopButton:hover, #resetButton:hover {
      background-color: var(--button-hover-bg);
      border-color: var(--primary-color);
    }

    #startStopButton:active, #resetButton:active {
      transform: scale(0.98);
    }

    /* Style for object input sections */
    .object-input-section {
        border: 1px solid var(--border-color);
        border-radius: var(--border-radius);
        padding: 0.75rem;
        margin-top: 1rem;
        background-color: var(--input-bg);
    }

    .object-input-section h3 {
        font-size: 1.05rem;
        color: var(--primary-color);
        margin-bottom: 0.6rem;
        border-bottom: 1px solid var(--border-color);
        padding-bottom: 0.4rem;
    }

    .add-object-button {
        padding: 0.5rem 1rem;
        font-size: 0.9rem;
        border: 1px solid var(--primary-color);
        border-radius: var(--border-radius);
        background-color: var(--primary-color);
        color: white;
        cursor: pointer;
        transition: background-color 0.2s ease, border-color 0.2s ease;
        font-weight: 500;
        margin-top: 1rem;
        display: block; /* Make it a block element to center or control layout */
        margin-left: auto;
        margin-right: auto;
    }

    .add-object-button:hover {
        background-color: #004494;
        border-color: #004494;
    }

    .clear-button {
        padding: 0.4rem 0.8rem;
        font-size: 0.85rem;
        border: 1px solid #dc3545;
        border-radius: var(--border-radius);
        background-color: #ffffff;
        color: #dc3545;
        cursor: pointer;
        transition: background-color 0.2s ease, color 0.2s ease;
        font-weight: 500;
        margin-top: 0.5rem;
        margin-bottom: 0.25rem;
        display: inline-block;
    }

    .clear-button:hover {
        background-color: #dc3545;
        color: white;
    }

    .clear-button:active {
        background-color: #c82333;
        border-color: #c82333;
    }

    @media (prefers-color-scheme: dark) {
        .clear-button {
            background-color: #21262d;
            border-color: #f85149;
            color: #f85149;
        }
        
        .clear-button:hover {
            background-color: #f85149;
            color: #0d1117;
        }

        .clear-button:active {
            background-color: #ec6547;
            border-color: #ec6547;
        }
    }

    /* Optimizer-specific styles */
    .object-input-section label[style*="float: right"] {
        color: var(--label-color);
        font-size: 0.85em;
        font-weight: normal;
    }

    .object-input-section input[type="checkbox"] {
        accent-color: var(--primary-color);
        transform: scale(1.1);
    }

    .object-input-section h3 {
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    .form-group label input[type="checkbox"] {
        accent-color: var(--primary-color);
        transform: scale(1.1);
        margin-right: 8px;
    }

    /* Slider group styling */
    .slider-group {
        flex-direction: column;
        align-items: stretch;
        gap: 0.3rem;
    }

    .slider-group label {
        flex: none;
        margin-bottom: 0.2rem;
    }

    .slider-control-row {
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }

    .slider-group input[type="range"] {
        flex: 1;
        margin: 0;
        cursor: pointer;
        -webkit-appearance: none;
        appearance: none;
        height: 6px;
        border-radius: 3px;
        background: var(--border-color);
        outline: none;
    }

    .slider-group input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: var(--primary-color);
        border: 2px solid var(--container-bg);
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
        cursor: pointer;
    }

    .slider-group input[type="range"]::-moz-range-thumb {
        width: 18px;
        height: 18px;
        border: none;
        border-radius: 50%;
        background: var(--primary-color);
        cursor: pointer;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
    }

    .slider-group input[type="number"] {
        flex: none;
        width: 80px;
        margin: 0;
    }

  </style>
</head>
<body>
  <div class="wrapper">
    <div class="top-container" id="mainContainer">
      <div class="container" id="inputContainer">
        <div class="header">
          <h1>Kinematics Calculator</h1>
          <div class="modeToggle">
            <input type="radio" name="mode" id="mode1D" value="1d" checked />
            <label for="mode1D">1D</label>
            <input type="radio" name="mode" id="mode2D" value="basic" />
            <label for="mode2D">2D</label>
            <input type="radio" name="mode" id="modeDesign" value="design" />
            <label for="modeDesign">Design</label>
            <input type="radio" name="mode" id="modeMultiObject1D" value="multiObject1D" />
            <label for="modeMultiObject1D">Multi-Object 1D</label>
            <input type="radio" name="mode" id="modeOptimizer" value="optimizer" />
            <label for="modeOptimizer">Optimizer</label>
          </div>
        </div>
        <div id="oneDInputs">
          <p class="note">Fill in <strong>exactly three</strong> of the following five fields. The two missing variables will be calculated.</p>
          <div class="form-group">
            <label for="v1d">Initial Velocity, V<sub>i</sub> <span class="unit">(m/s)</span></label>
            <input type="number" id="v1d" />
          </div>
          <div class="form-group">
            <label for="vf1d">Final Velocity, V<sub>f</sub> <span class="unit">(m/s)</span></label>
            <input type="number" id="vf1d" />
          </div>
          <div class="form-group">
            <label for="a1d">Acceleration, a <span class="unit">(m/s²)</span></label>
            <input type="number" id="a1d" />
          </div>
          <div class="form-group">
            <label for="d1d">Displacement, d <span class="unit">(m)</span></label>
            <input type="number" id="d1d" />
          </div>
          <div class="form-group">
            <label for="t1d">Time, t <span class="unit">(s)</span></label>
            <input type="number" id="t1d" />
          </div>
          <button class="clear-button" id="clear1D">Clear All</button>
        </div>
        <div id="basicInputs" class="hidden">
          <p class="note">Fill in <strong>exactly three</strong> of these fields: Initial Velocity (V<sub>i</sub>), &Delta;x, &Delta;y, and Launch Angle (&theta;). Time (t) is optional.</p>
          <div class="form-group">
            <label for="vi">Initial Velocity, V<sub>i</sub> <span class="unit">(m/s)</span></label>
            <input type="number" id="vi" />
          </div>
          <div class="form-group">
            <label for="dx">Horizontal Displacement, &Delta;x <span class="unit">(m)</span></label>
            <input type="number" id="dx" />
          </div>
          <div class="form-group">
            <label for="dy">Vertical Displacement, &Delta;y <span class="unit">(m)</span></label>
            <input type="number" id="dy" />
          </div>
          <div class="form-group">
            <label for="angle">Launch Angle, &theta; <span class="unit">(°)</span></label>
            <input type="number" id="angle" />
          </div>
          <div class="form-group">
            <label for="time">Time (optional), t <span class="unit">(s)</span></label>
            <input type="number" id="time" />
          </div>
          <button class="clear-button" id="clearBasic">Clear All</button>
        </div>
        <div id="designInputs" class="hidden">
          <p class="note">Enter target displacements (&Delta;x and &Delta;y) and the desired landing angle (&phi;). The calculator computes the required launch angle and initial speed.</p>
          <div class="form-group">
            <label for="dxDesign">Target &Delta;x <span class="unit">(m)</span></label>
            <input type="number" id="dxDesign" />
          </div>
          <div class="form-group">
            <label for="dyDesign">Target &Delta;y <span class="unit">(m)</span></label>
            <input type="number" id="dyDesign" />
          </div>
          <div class="form-group">
            <label for="landingAngle">Landing Angle, &phi; <span class="unit">(°)</span></label>
            <input type="number" id="landingAngle" />
          </div>
          <button class="clear-button" id="clearDesign">Clear All</button>
        </div>

        <!-- NEW: Multi-Object 1D Inputs -->
        <div id="multiObject1DInputs" class="hidden">
            <p class="note">Enter initial position, initial velocity, and acceleration for each object. The graph will show their positions over time and any meeting points.</p>

            <div class="object-input-section">
                <h3>Object 1</h3>
                <div class="form-group">
                    <label for="obj1_x0">Initial Position, x<sub>0</sub> <span class="unit">(m)</span></label>
                    <input type="number" id="obj1_x0" />
                </div>
                <div class="form-group">
                    <label for="obj1_v0">Initial Velocity, V<sub>i</sub> <span class="unit">(m/s)</span></label>
                    <input type="number" id="obj1_v0" />
                </div>
                <div class="form-group">
                    <label for="obj1_a">Acceleration, a <span class="unit">(m/s²)</span></label>
                    <input type="number" id="obj1_a" />
                </div>
            </div>

            <div class="object-input-section">
                <h3>Object 2</h3>
                <div class="form-group">
                    <label for="obj2_x0">Initial Position, x<sub>0</sub> <span class="unit">(m)</span></label>
                    <input type="number" id="obj2_x0" />
                </div>
                <div class="form-group">
                    <label for="obj2_v0">Initial Velocity, V<sub>i</sub> <span class="unit">(m/s)</span></label>
                    <input type="number" id="obj2_v0" />
                </div>
                <div class="form-group">
                    <label for="obj2_a">Acceleration, a <span class="unit">(m/s²)</span></label>
                    <input type="number" id="obj2_a" />
                </div>
            </div>

            <div class="object-input-section hidden" id="object3Inputs">
                <h3>Object 3</h3>
                <div class="form-group">
                    <label for="obj3_x0">Initial Position, x<sub>0</sub> <span class="unit">(m)</span></label>
                    <input type="number" id="obj3_x0" />
                </div>
                <div class="form-group">
                    <label for="obj3_v0">Initial Velocity, V<sub>i</sub> <span class="unit">(m/s)</span></label>
                    <input type="number" id="obj3_v0" />
                </div>
                <div class="form-group">
                    <label for="obj3_a">Acceleration, a <span class="unit">(m/s²)</span></label>
                    <input type="number" id="obj3_a" />
                </div>
            </div>

            <button id="addObject3Button" class="add-object-button">Add Object 3</button>
            <button class="clear-button" id="clearMultiObject">Clear All</button>
        </div>
        <!-- END NEW: Multi-Object 1D Inputs -->

        <!-- NEW: Optimizer Inputs -->
        <div id="optimizerInputs" class="hidden">
            <p class="note">Compare two projectile trajectories. Use optimization to find maximum range angles. Visualize trajectory envelopes.</p>

            <div class="object-input-section">
                <h3>Trajectory A <label style="float: right; font-size: 0.85em; font-weight: normal;"><input type="checkbox" id="showTrajectoryA" checked style="margin-right: 4px;">Show</label></h3>
                
                <div class="form-group slider-group">
                    <label for="angleA">Launch Angle, θ<sub>A</sub> <span class="unit">(°)</span></label>
                    <div class="slider-control-row">
                        <input type="range" id="angleASlider" min="0.1" max="89.9" step="0.1" value="45" />
                        <input type="number" id="angleA" value="45" min="0.1" max="89.9" step="0.1" />
                    </div>
                </div>
                
                <div class="form-group slider-group">
                    <label for="speedA">Initial Speed, V<sub>A</sub> <span class="unit">(m/s)</span></label>
                    <div class="slider-control-row">
                        <input type="range" id="speedASlider" min="1" max="100" step="0.1" value="30" />
                        <input type="number" id="speedA" value="30" min="0.1" step="0.1" />
                    </div>
                </div>
                
                <div class="form-group slider-group">
                    <label for="heightA">Launch Height, h<sub>A</sub> <span class="unit">(m)</span></label>
                    <div class="slider-control-row">
                        <input type="range" id="heightASlider" min="0" max="50" step="0.1" value="10" />
                        <input type="number" id="heightA" value="10" min="0" step="0.1" />
                    </div>
                </div>
                
                <button id="optimizeA" class="add-object-button" style="background-color: #1e90ff; border-color: #1e90ff;">★ Optimize A for Max Range</button>
            </div>

            <div class="object-input-section">
                <h3>Trajectory B <label style="float: right; font-size: 0.85em; font-weight: normal;"><input type="checkbox" id="showTrajectoryB" checked style="margin-right: 4px;">Show</label></h3>
                
                <div class="form-group slider-group">
                    <label for="angleB">Launch Angle, θ<sub>B</sub> <span class="unit">(°)</span></label>
                    <div class="slider-control-row">
                        <input type="range" id="angleBSlider" min="0.1" max="89.9" step="0.1" value="35" />
                        <input type="number" id="angleB" value="35" min="0.1" max="89.9" step="0.1" />
                    </div>
                </div>
                
                <div class="form-group slider-group">
                    <label for="speedB">Initial Speed, V<sub>B</sub> <span class="unit">(m/s)</span></label>
                    <div class="slider-control-row">
                        <input type="range" id="speedBSlider" min="1" max="100" step="0.1" value="30" />
                        <input type="number" id="speedB" value="30" min="0.1" step="0.1" />
                    </div>
                </div>
                
                <div class="form-group slider-group">
                    <label for="heightB">Launch Height, h<sub>B</sub> <span class="unit">(m)</span></label>
                    <div class="slider-control-row">
                        <input type="range" id="heightBSlider" min="0" max="50" step="0.1" value="10" />
                        <input type="number" id="heightB" value="10" min="0" step="0.1" />
                    </div>
                </div>
                
                <button id="optimizeB" class="add-object-button" style="background-color: #ff4500; border-color: #ff4500;">★ Optimize B for Max Range</button>
            </div>

            <button class="clear-button" id="clearOptimizer">Clear All</button>
        </div>
        <!-- END NEW: Optimizer Inputs -->

        <div id="gravityBox" class="form-group hidden" style="margin-top: 0.75rem; border-top: 1px solid var(--border-color); padding-top: 0.75rem;">
          <label for="acceleration">Gravitational Accel., g <span class="unit">(m/s²)</span></label>
          <input type="number" id="acceleration" value="9.81" />
        </div>
      </div>
      
      <!-- Results Container - Right side for non-optimizer modes -->
      <div class="container" id="resultContainer">
        <h2>Results</h2>
        <div id="message">
          <p class="note">Enter parameters in the relevant section on the left to see results.</p>
        </div>
      </div>
    </div>
    
    <!-- Results Container for Optimizer Mode - Bottom -->
    <div class="container hidden" id="optimizerResultContainer">
      <h2>Results</h2>
      <div id="optimizerMessage">
        <p class="note">Enter parameters in the optimizer section to see results.</p>
      </div>
    </div>
    
    <!-- Trajectory Panel for all modes -->
    <div class="container hidden" id="trajectoryPanel">
      <h2 id="trajectoryTitle">Trajectory Visualization</h2>
      <div id="trajectoryPanelInner">
        <!-- Container for canvas, slider, and buttons -->
        <div id="trajectoryContainer">
          <canvas id="trajectoryCanvas" width="800" height="400"></canvas>
          <div id="trajectoryControls">
            <input type="range" id="trajectorySlider" min="0" max="100" value="0" step="0.1" />
            <div class="buttonContainer">
              <button id="startStopButton">Start</button>
              <button id="resetButton">Reset</button>
            </div>
          </div>
        </div>
        <!-- Separate container for the current state display -->
        <div id="stateDisplayContainer">
          <div id="stateDisplay">
            <h3>Current State</h3>
            <div id="stateValues">
              <p><strong>Time:</strong> <span>-- s</span></p>
              <p><strong>dx:</strong> <span>-- m</span></p>
              <p><strong>dy:</strong> <span>-- m</span></p>
              <p><strong>vx:</strong> <span>-- m/s</span></p>
              <p><strong>vy:</strong> <span>-- m/s</span></p>
              <p><strong>Speed:</strong> <span>-- m/s</span></p>
              <p><strong>Angle:</strong> <span>-- °</span></p>
            </div>
          </div>
        </div>
      </div>
      
      <!-- Optimizer Display Options (only visible in optimizer mode) -->
      <div id="optimizerDisplayOptions" class="hidden">
        <div class="display-options-header" onclick="toggleDisplayOptions()">
          <span>Display Options</span>
          <span class="display-options-toggle">▼</span>
        </div>
        <div class="display-options-content" id="displayOptionsContent">
          <div class="form-group">
            <label>
              <input type="checkbox" id="showEnvelopeA" checked style="margin-right: 8px;">
              Show Trajectory A Envelope
            </label>
          </div>
          <div class="form-group">
            <label>
              <input type="checkbox" id="showEnvelopeB" checked style="margin-right: 8px;">
              Show Trajectory B Envelope
            </label>
          </div>
          <div class="form-group">
            <label>
              <input type="checkbox" id="showOptimalPaths" checked style="margin-right: 8px;">
              Show Optimal Range Paths
            </label>
          </div>
        </div>
      </div>
    </div>

        <script>
            // PWA: Service worker registration
            if ('serviceWorker' in navigator) {
                window.addEventListener('load', () => {
                    navigator.serviceWorker.register('./sw.js').catch(console.error);
                });
            }
        </script>
        <script>
      // --- Constants ---
      const G_DEFAULT = 9.81; // Default gravitational acceleration
      const TOLERANCE = 1e-9; // For floating-point comparisons
      const ANIMATION_DURATION = 3000; // 3000ms for full animation playback
      const MEETING_POINT_CLICK_RADIUS = 50; // Pixels radius for clicking a meeting point
      const GRAPH_MARGIN = 50; // Fixed margin for the multi-object graph axes

      // --- Global State Variables ---
      let globalPoints = []; // Trajectory points
      let globalScale = 1; // Canvas scale factor (for 2D)
      let globalScaleX = 1; // Canvas scale factor for X-axis (for 1D multi-object)
      let globalScaleY = 1; // Canvas scale factor for Y-axis (for 1D multi-object)
      let globalOffsetX = 0; // X offset for centering
      let globalOffsetY = 0; // Y offset for centering
      let global_t_flight = 0; // Total flight time (for 2D)
      let globalVix = 0; // Initial horizontal velocity (for 2D animation)
      let globalViy = 0; // Initial vertical velocity (for 2D animation)
      let globalG = G_DEFAULT; // Gravity used in current calculation
      let globalVerticalShift = 0; // Vertical shift applied to trajectory (for 2D)

      // NEW: Multi-object 1D specific globals
      let multiObjectData = []; // Stores {x0, v0, a, color, label} for each object (input data)
      const objectColors = ["#1e90ff", "#ff4500", "#32cd32"]; // Blue, OrangeRed, LimeGreen
      let showObject3 = false; // State for showing/hiding object 3 inputs
      let globalMaxTime = 0; // Max time for 1D multi-object graph
      let globalMinPosition = 0; // Min position for 1D multi-object graph
      let globalMaxPosition = 0; // Max position for 1D multi-object graph
      let globalMeetingPoints = []; // Stores {t, x, objects} for meeting points in 1D multi-object

      // NEW: Optimizer specific globals
      const optimizerColors = {
        trajectoryA: "#1e90ff",     // Blue for trajectory A
        trajectoryB: "#ff4500",     // Orange for trajectory B
        optimalA: "#32cd32",        // Green for optimal A
        optimalB: "#9370db",        // Purple for optimal B
        envelopeA: "#1e90ff",       // Blue envelope (matches A)
        envelopeB: "#ff4500"        // Orange envelope (matches B)
      };
      let optimizerAnimationData = {
        running: false,
        time: 0,
        lastTimestamp: 0,
        trajectoryA: null,
        trajectoryB: null,
        optimalA: null,
        optimalB: null
      };

      // Animation control
      let animationFrameId = null;
      let autoAnimating = false;
      let animationStartTime = null;
      let pausedProgress = 0;

      // --- DOM Elements ---
      const modeRadios = document.getElementsByName("mode");
      const oneDInputsDiv = document.getElementById("oneDInputs");
      const basicInputsDiv = document.getElementById("basicInputs");
      const designInputsDiv = document.getElementById("designInputs");
      const multiObject1DInputsDiv = document.getElementById("multiObject1DInputs"); // NEW
      const optimizerInputsDiv = document.getElementById("optimizerInputs"); // NEW
      const object3InputsDiv = document.getElementById("object3Inputs"); // NEW
      const addObject3Button = document.getElementById("addObject3Button"); // NEW
      const gravityBox = document.getElementById("gravityBox");
      const startStopButton = document.getElementById("startStopButton");
      const resetButton = document.getElementById("resetButton");
      const trajectorySlider = document.getElementById("trajectorySlider");
      const allNumberInputs = document.querySelectorAll("input[type='number']");
      const stateDisplayValues = document.getElementById("stateValues");
      const trajectoryPanel = document.getElementById("trajectoryPanel");
      const trajectoryCanvas = document.getElementById("trajectoryCanvas");
      const resultContainer = document.getElementById("resultContainer");
      const optimizerResultContainer = document.getElementById("optimizerResultContainer");
      const messageDiv = document.getElementById("message");
      const optimizerMessageDiv = document.getElementById("optimizerMessage");

      // --- Helper functions for converting data coordinates to canvas coordinates (Multi-Object 1D) ---
      /**
       * Converts a time (t) data coordinate to a canvas X-coordinate.
       * @param {number} t - The time value.
       * @returns {number} The corresponding canvas X-coordinate.
       */
      function dataToCanvasX(t) {
          // globalOffsetX is the canvas X for data t=0 (left edge of plotting area)
          return globalOffsetX + t * globalScaleX;
      }

      /**
       * Converts a position (x) data coordinate to a canvas Y-coordinate.
       * @param {number} x - The position value.
       * @returns {number} The corresponding canvas Y-coordinate.
       */
      function dataToCanvasY(x) {
          // globalOffsetY is the canvas Y for data x=globalMinPosition (bottom of plot area).
          // To map x to canvas Y, we calculate its position relative to globalMinPosition,
          // scale it, and subtract from globalOffsetY because canvas Y increases downwards.
          return globalOffsetY - (x - globalMinPosition) * globalScaleY;
      }


      // --- Event Listeners ---
      document.addEventListener("DOMContentLoaded", () => {
          modeRadios.forEach(radio => radio.addEventListener("change", handleModeChange));
          // Attach listeners to all number inputs for debounced calculation
          allNumberInputs.forEach(input => input.addEventListener("input", debounce(calculate, 250)));
          if (startStopButton) startStopButton.addEventListener("click", toggleAnimation);
          if (resetButton) resetButton.addEventListener("click", resetAnimation);
          if (trajectorySlider) { // Ensure slider exists before adding listener
            trajectorySlider.addEventListener("input", handleSliderInput);
            trajectorySlider.addEventListener("change", handleSliderChange);
          }
          if (addObject3Button) addObject3Button.addEventListener("click", toggleObject3Inputs); // NEW
          
          // Clear button event listeners
          const clear1DButton = document.getElementById("clear1D");
          const clearBasicButton = document.getElementById("clearBasic");
          const clearDesignButton = document.getElementById("clearDesign");
          const clearMultiObjectButton = document.getElementById("clearMultiObject");
          const clearOptimizerButton = document.getElementById("clearOptimizer");
          
          if (clear1DButton) clear1DButton.addEventListener("click", clear1DInputs);
          if (clearBasicButton) clearBasicButton.addEventListener("click", clearBasicInputs);
          if (clearDesignButton) clearDesignButton.addEventListener("click", clearDesignInputs);
          if (clearMultiObjectButton) clearMultiObjectButton.addEventListener("click", clearMultiObjectInputs);
          if (clearOptimizerButton) clearOptimizerButton.addEventListener("click", clearOptimizerInputs);
          
          // NEW: Optimizer button event listeners
          const optimizeAButton = document.getElementById("optimizeA");
          const optimizeBButton = document.getElementById("optimizeB");
          
          if (optimizeAButton) optimizeAButton.addEventListener("click", optimizeTrajectoryA);
          if (optimizeBButton) optimizeBButton.addEventListener("click", optimizeTrajectoryB);
          
          // NEW: Optimizer checkbox event listeners
          const showTrajectoryACheckbox = document.getElementById("showTrajectoryA");
          const showTrajectoryBCheckbox = document.getElementById("showTrajectoryB");
          const showEnvelopeACheckbox = document.getElementById("showEnvelopeA");
          const showEnvelopeBCheckbox = document.getElementById("showEnvelopeB");
          const showOptimalPathsCheckbox = document.getElementById("showOptimalPaths");
          
          if (showTrajectoryACheckbox) showTrajectoryACheckbox.addEventListener("change", handleOptimizerDisplayChange);
          if (showTrajectoryBCheckbox) showTrajectoryBCheckbox.addEventListener("change", handleOptimizerDisplayChange);
          if (showEnvelopeACheckbox) showEnvelopeACheckbox.addEventListener("change", handleOptimizerDisplayChange);
          if (showEnvelopeBCheckbox) showEnvelopeBCheckbox.addEventListener("change", handleOptimizerDisplayChange);
          if (showOptimalPathsCheckbox) showOptimalPathsCheckbox.addEventListener("change", handleOptimizerDisplayChange);
          
          // NEW: Slider synchronization for optimizer mode
          function syncInputAndSlider(inputId, sliderId) {
              const input = document.getElementById(inputId);
              const slider = document.getElementById(sliderId);
              
              if (input && slider) {
                  // When input changes, update slider and recalculate immediately
                  input.addEventListener('input', function(e) {
                      const value = parseFloat(this.value) || 0;
                      slider.value = value;
                      const mode = getSelectedMode();
                      if (mode === 'optimizer') {
                          // Prevent the debounced calculation and calculate immediately
                          e.stopPropagation();
                          calculateOptimizerMode();
                      }
                  });
                  
                  // When slider changes, update input and recalculate immediately  
                  slider.addEventListener('input', function() {
                      input.value = this.value;
                      const mode = getSelectedMode();
                      if (mode === 'optimizer') {
                          calculateOptimizerMode(); // Immediate update while dragging
                      }
                  });
              }
          }

          // Set up all slider synchronizations
          syncInputAndSlider('angleA', 'angleASlider');
          syncInputAndSlider('speedA', 'speedASlider');
          syncInputAndSlider('heightA', 'heightASlider');
          syncInputAndSlider('angleB', 'angleBSlider');
          syncInputAndSlider('speedB', 'speedBSlider');
          syncInputAndSlider('heightB', 'heightBSlider');
          
          // Initialize slider values to match inputs on page load
          function initializeSliderValues() {
              ['angleA', 'speedA', 'heightA', 'angleB', 'speedB', 'heightB'].forEach(inputId => {
                  const input = document.getElementById(inputId);
                  const slider = document.getElementById(inputId.replace(/[AB]$/, '$&Slider'));
                  if (input && slider && input.value) {
                      slider.value = input.value;
                  }
              });
          }
          
          initializeSliderValues();
          
          // NEW: Add click listener to canvas for meeting points
          if (trajectoryCanvas) trajectoryCanvas.addEventListener("click", handleCanvasClick);

          updateModeVisibility();
          calculate();
      });

      // --- Debounce Function ---
      function debounce(func, wait) {
          let timeout;
          return function executedFunction(...args) {
              const later = () => {
                  clearTimeout(timeout);
                  func.apply(this, args);
              };
              clearTimeout(timeout);
              timeout = setTimeout(later, wait);
          };
      }

      // --- Mode Switching Logic ---
      function handleModeChange() {
          updateModeVisibility();
          calculate();
      }

      function getSelectedMode() {
          const checkedRadio = document.querySelector("input[name='mode']:checked");
          return checkedRadio ? checkedRadio.value : "1d";
      }

      function updateModeVisibility() {
          const mode = getSelectedMode();
          const optimizerDisplayOptions = document.getElementById("optimizerDisplayOptions");
          const trajectoryTitle = document.getElementById("trajectoryTitle");
          const wrapper = document.querySelector('.wrapper');
          
          oneDInputsDiv.classList.toggle("hidden", mode !== "1d");
          basicInputsDiv.classList.toggle("hidden", mode !== "basic");
          designInputsDiv.classList.toggle("hidden", mode !== "design");
          multiObject1DInputsDiv.classList.toggle("hidden", mode !== "multiObject1D");
          optimizerInputsDiv.classList.toggle("hidden", mode !== "optimizer");
          gravityBox.classList.toggle("hidden", mode === "1d" || mode === "multiObject1D");
          
          // Apply optimizer-specific layout and result containers
          if (mode === "optimizer") {
              wrapper.classList.add("optimizer-mode");
              resultContainer.classList.add("hidden");
              optimizerResultContainer.classList.remove("hidden");
          } else {
              wrapper.classList.remove("optimizer-mode");
              resultContainer.classList.remove("hidden");
              optimizerResultContainer.classList.add("hidden");
          }
          
          // Show/hide trajectory panel based on mode
          trajectoryPanel.classList.toggle("hidden", mode === "1d");
          
          // Show optimizer display options only in optimizer mode
          if (optimizerDisplayOptions) {
              optimizerDisplayOptions.classList.toggle("hidden", mode !== "optimizer");
          }

          // Manage Object 3 visibility
          if (mode === "multiObject1D") {
              object3InputsDiv.classList.toggle("hidden", !showObject3);
              addObject3Button.textContent = showObject3 ? "Remove Object 3" : "Add Object 3";
          } else {
              object3InputsDiv.classList.add("hidden");
              addObject3Button.textContent = "Add Object 3";
              showObject3 = false;
          }

          // Update trajectory title based on mode
          if (trajectoryTitle) {
              if (mode === "multiObject1D") {
                  trajectoryTitle.textContent = "Position-Time Graph (1D)";
              } else if (mode === "optimizer") {
                  trajectoryTitle.textContent = "Projectile Optimizer (2D)";
              } else {
                  trajectoryTitle.textContent = "Trajectory Visualization (2D)";
              }
          }

          clearMessages();
          if (mode === '1d') {
               showNote("1D Mode: Fill in <strong>exactly three</strong> fields.");
          } else if (mode === 'basic') {
               showNote("2D Mode: Fill in <strong>exactly three</strong> of V<sub>i</sub>, &Delta;x, &Delta;y, &theta;.");
          } else if (mode === 'design') {
               showNote("Design Mode: Fill in target &Delta;x, &Delta;y, and landing angle &phi;.");
          } else if (mode === 'multiObject1D') {
               showNote("Multi-Object 1D Mode: Enter initial position, initial velocity, and acceleration for each object. The graph will show their positions over time and any meeting points.");
          } else if (mode === 'optimizer') {
               showNote("Optimizer Mode: Compare two projectile trajectories. Use sliders for real-time visualization. Optimize for maximum range angles.");
          }
          resetAnimation();
      }

      // NEW: Toggle Object 3 inputs
      function toggleObject3Inputs() {
          showObject3 = !showObject3;
          updateModeVisibility(); // Re-run visibility update to apply changes
          calculate(); // Recalculate with new object count
      }

      // --- Message Display Functions ---
      function clearMessages() {
          const mode = getSelectedMode();
          if (mode === "optimizer") {
              optimizerMessageDiv.innerHTML = "";
          } else {
              messageDiv.innerHTML = "";
          }
      }

      function showResult(htmlContent) {
           const mode = getSelectedMode();
           clearMessages();
           if (mode === "optimizer") {
               if (!optimizerResultContainer.querySelector('h2')) {
                   optimizerResultContainer.insertAdjacentHTML('afterbegin', '<h2>Results</h2>');
               }
               optimizerMessageDiv.innerHTML = `<div class="result">${htmlContent}</div>`;
           } else {
               if (!resultContainer.querySelector('h2')) {
                   resultContainer.insertAdjacentHTML('afterbegin', '<h2>Results</h2>');
               }
               messageDiv.innerHTML = `<div class="result">${htmlContent}</div>`;
           }
      }

      function showError(text) {
           const mode = getSelectedMode();
           clearMessages();
           if (mode === "optimizer") {
               if (!optimizerResultContainer.querySelector('h2')) {
                   optimizerResultContainer.insertAdjacentHTML('afterbegin', '<h2>Results</h2>');
               }
               optimizerMessageDiv.innerHTML = `<div class="error">${text}</div>`;
           } else {
               if (!resultContainer.querySelector('h2')) {
                   resultContainer.insertAdjacentHTML('afterbegin', '<h2>Results</h2>');
               }
               messageDiv.innerHTML = `<div class="error">${text}</div>`;
           }
      }

      function showNote(text) {
           const mode = getSelectedMode();
           clearMessages();
           if (mode === "optimizer") {
               if (!optimizerResultContainer.querySelector('h2')) {
                   optimizerResultContainer.insertAdjacentHTML('afterbegin', '<h2>Results</h2>');
               }
               optimizerMessageDiv.innerHTML = `<div class="note">${text}</div>`;
           } else {
               if (!resultContainer.querySelector('h2')) {
                   resultContainer.insertAdjacentHTML('afterbegin', '<h2>Results</h2>');
               }
               messageDiv.innerHTML = `<div class="note">${text}</div>`;
           }
      }

      // --- Input Parsing ---
      function getFloatValue(id, allowEmpty = false) {
          const element = document.getElementById(id);
          if (!element) return NaN;
          const value = element.value.trim();
          if (value === "") {
              return allowEmpty ? null : NaN;
          }
          const num = parseFloat(value);
          return isNaN(num) ? NaN : num;
      }

      // --- Result Formatting ---
      function formatResultLine(label, value, unit) {
          let displayValue;
          if (typeof value === "number" && isFinite(value)) {
              const precision = (label.includes("&theta;") || label.includes("&phi;")) ? 3 : 2;
              displayValue = (Math.abs(value) < TOLERANCE * 10) ? (0).toFixed(precision) : value.toFixed(precision);
          } else {
              displayValue = value;
          }
          return `<p><strong>${label}:</strong> <span>${displayValue}</span> <span class="unit">${unit}</span></p>`;
      }

      // --- Clear Input Functions ---
      function clear1DInputs() {
          document.getElementById("v1d").value = "";
          document.getElementById("vf1d").value = "";
          document.getElementById("a1d").value = "";
          document.getElementById("d1d").value = "";
          document.getElementById("t1d").value = "";
          clearMessages();
          showNote("1D Mode: Fill in <strong>exactly three</strong> fields.");
      }

      function clearBasicInputs() {
          document.getElementById("vi").value = "";
          document.getElementById("dx").value = "";
          document.getElementById("dy").value = "";
          document.getElementById("angle").value = "";
          document.getElementById("time").value = "";
          clearMessages();
          resetAnimation();
          showNote("2D Mode: Fill in <strong>exactly three</strong> of V<sub>i</sub>, &Delta;x, &Delta;y, &theta;.");
      }

      function clearDesignInputs() {
          document.getElementById("dxDesign").value = "";
          document.getElementById("dyDesign").value = "";
          document.getElementById("landingAngle").value = "";
          clearMessages();
          resetAnimation();
          showNote("Design Mode: Fill in target &Delta;x, &Delta;y, and landing angle &phi;.");
      }

      function clearMultiObjectInputs() {
          document.getElementById("obj1_x0").value = "";
          document.getElementById("obj1_v0").value = "";
          document.getElementById("obj1_a").value = "";
          document.getElementById("obj2_x0").value = "";
          document.getElementById("obj2_v0").value = "";
          document.getElementById("obj2_a").value = "";
          document.getElementById("obj3_x0").value = "";
          document.getElementById("obj3_v0").value = "";
          document.getElementById("obj3_a").value = "";
          
          // Reset Object 3 visibility if it's shown
          if (showObject3) {
              showObject3 = false;
              updateModeVisibility();
          }
          
          clearMessages();
          resetAnimation();
          showNote("Multi-Object 1D Mode: Enter initial position, initial velocity, and acceleration for each object. The graph will show their positions over time and any meeting points.");
      }

      function clearOptimizerInputs() {
          // Reset input values to defaults
          document.getElementById("angleA").value = "45";
          document.getElementById("speedA").value = "30";
          document.getElementById("heightA").value = "10";
          document.getElementById("angleB").value = "35";
          document.getElementById("speedB").value = "30";
          document.getElementById("heightB").value = "10";
          
          // Sync sliders with input values
          document.getElementById("angleASlider").value = "45";
          document.getElementById("speedASlider").value = "30";
          document.getElementById("heightASlider").value = "10";
          document.getElementById("angleBSlider").value = "35";
          document.getElementById("speedBSlider").value = "30";
          document.getElementById("heightBSlider").value = "10";
          
          // Reset checkboxes to default
          document.getElementById("showTrajectoryA").checked = true;
          document.getElementById("showTrajectoryB").checked = true;
          document.getElementById("showEnvelopeA").checked = true;
          document.getElementById("showEnvelopeB").checked = true;
          document.getElementById("showOptimalPaths").checked = true;
          
          clearMessages();
          resetAnimation();
          calculate(); // Recalculate with default values
          showNote("Optimizer Mode: Compare two projectile trajectories. Use optimization to find maximum range angles. Visualize trajectory envelopes.");
      }

      function optimizeTrajectoryA() {
          const speedA = getFloatValue("speedA");
          const heightA = getFloatValue("heightA");
          const g = getFloatValue("acceleration", false) || G_DEFAULT;
          
          if (isNaN(speedA) || isNaN(heightA) || speedA <= 0) {
              showError("Please enter valid positive values for Speed A and Height A.");
              return;
          }
          
          try {
              const optimal = optimizeAngle(speedA, g, heightA);
              const optimalAngleDeg = toDegrees(optimal.theta);
              document.getElementById("angleA").value = optimalAngleDeg.toFixed(1);
              calculate(); // Recalculate with new angle
          } catch (e) {
              showError("Error optimizing trajectory A: " + e.message);
          }
      }

      function optimizeTrajectoryB() {
          const speedB = getFloatValue("speedB");
          const heightB = getFloatValue("heightB");
          const g = getFloatValue("acceleration", false) || G_DEFAULT;
          
          if (isNaN(speedB) || isNaN(heightB) || speedB <= 0) {
              showError("Please enter valid positive values for Speed B and Height B.");
              return;
          }
          
          try {
              const optimal = optimizeAngle(speedB, g, heightB);
              const optimalAngleDeg = toDegrees(optimal.theta);
              document.getElementById("angleB").value = optimalAngleDeg.toFixed(1);
              calculate(); // Recalculate with new angle
          } catch (e) {
              showError("Error optimizing trajectory B: " + e.message);
          }
      }

      function handleOptimizerDisplayChange() {
          const mode = getSelectedMode();
          if (mode === "optimizer") {
              drawOptimizerVisualization(); // Redraw with new display settings
          }
      }

      function toggleDisplayOptions() {
          const content = document.getElementById('displayOptionsContent');
          const toggle = document.querySelector('.display-options-toggle');
          
          if (content && toggle) {
              content.classList.toggle('expanded');
              toggle.classList.toggle('expanded');
          }
      }

      // --- 1D Kinematics Calculation (MODIFIED) ---
      function calculate1DMode() {
          const vi = getFloatValue("v1d", true);
          const vf = getFloatValue("vf1d", true);
          const a = getFloatValue("a1d", true);
          const d = getFloatValue("d1d", true);
          const t = getFloatValue("t1d", true);

          const variables = { vi, vf, a, d, t };
          const providedKeys = Object.keys(variables).filter(key => variables[key] !== null && isFinite(variables[key]));

          if (providedKeys.length !== 3) {
              showNote("1D Mode: Please fill in exactly <strong>three</strong> fields.");
              return;
          }

          let sol = { ...variables };
          const has = {
              vi: providedKeys.includes("vi"),
              vf: providedKeys.includes("vf"),
              a: providedKeys.includes("a"),
              d: providedKeys.includes("d"),
              t: providedKeys.includes("t")
          };

          try {
              if (has.vi && has.vf && has.t) {
                  if (Math.abs(sol.t) < TOLERANCE) throw new Error("Time (t) cannot be zero.");
                  sol.a = (sol.vf - sol.vi) / sol.t;
                  sol.d = sol.vi * sol.t + 0.5 * sol.a * sol.t * sol.t;
              } else if (has.vi && has.vf && has.a) {
                  if (Math.abs(sol.a) < TOLERANCE) {
                      if (Math.abs(sol.vf - sol.vi) > TOLERANCE) throw new Error("If acceleration is zero, Vi and Vf must be equal.");
                      sol.t = NaN; // Or Infinity, time is indeterminate if d is not known
                      sol.d = NaN;
                  } else {
                      sol.t = (sol.vf - sol.vi) / sol.a;
                      sol.d = sol.vi * sol.t + 0.5 * sol.a * sol.t * sol.t;
                  }
              } else if (has.vi && has.vf && has.d) {
                  const v_avg = (sol.vi + sol.vf) / 2;
                  if (Math.abs(v_avg) < TOLERANCE) {
                       if (Math.abs(sol.d) > TOLERANCE) throw new Error("Displacement must be zero if average velocity is zero.");
                       sol.t = NaN; // Time is indeterminate
                       sol.a = NaN; // Acceleration is indeterminate
                  } else {
                      sol.t = sol.d / v_avg;
                  }
                  if (sol.t < -TOLERANCE) throw new Error("Calculation resulted in negative time.");
                  sol.t = Math.max(0, sol.t);
                  if (Math.abs(sol.t) < TOLERANCE) {
                       if(Math.abs(sol.vf - sol.vi) > TOLERANCE) throw new Error("Vf and Vi must be equal if time is zero.");
                       sol.a = NaN; // Acceleration is indeterminate
                  } else {
                       sol.a = (sol.vf - sol.vi) / sol.t;
                  }
              } else if (has.vi && has.a && has.t) {
                  sol.vf = sol.vi + sol.a * sol.t;
                  sol.d = sol.vi * sol.t + 0.5 * sol.a * sol.t * sol.t;
              } else if (has.vi && has.a && has.d) {
                  const A = 0.5 * sol.a;
                  const B = sol.vi;
                  const C = -sol.d;

                  if (Math.abs(A) < TOLERANCE) { // Linear case: a=0
                      if (Math.abs(B) < TOLERANCE) { // vi=0
                          if (Math.abs(C) > TOLERANCE) throw new Error("Displacement must be zero if Vi and a are zero.");
                          sol.t = 0; // d=0, vi=0, a=0 -> t=0
                      } else { // vi != 0
                          sol.t = -C / B; // d = vi*t
                      }
                      if (sol.t < -TOLERANCE) throw new Error("Calculation resulted in negative time.");
                      sol.t = Math.max(0, sol.t);
                      sol.vf = sol.vi + sol.a * sol.t; // Since a=0, vf=vi
                  } else { // Quadratic case: a!=0
                      const disc = B * B - 4 * A * C;
                      if (disc < -TOLERANCE) throw new Error("No real solution for time.");
                      
                      const sqrtDisc = Math.sqrt(Math.max(0, disc));
                      const t1 = (-B + sqrtDisc) / (2 * A);
                      const t2 = (-B - sqrtDisc) / (2 * A);

                      const validTimes = [t1, t2]
                          .filter(t => t >= -TOLERANCE)
                          .map(t => Math.max(0, t));
                          
                      const uniqueTimes = [...new Set(validTimes.map(t => t.toPrecision(10)))].map(s => parseFloat(s));

                      if (uniqueTimes.length === 0) throw new Error("No positive real solution for time.");

                      let resultHTML = '';
                      uniqueTimes.sort((a, b) => a - b).forEach((t_sol, index) => {
                          const vf_sol = sol.vi + sol.a * t_sol;
                          resultHTML += `<div class="group-title">Solution ${index + 1}</div>`;
                          resultHTML += formatResultLine("Initial Velocity, V<sub>i</sub>", sol.vi, "m/s");
                          resultHTML += formatResultLine("Final Velocity, V<sub>f</sub>", vf_sol, "m/s");
                          resultHTML += formatResultLine("Acceleration, a", sol.a, "m/s²");
                          resultHTML += formatResultLine("Displacement, d", sol.d, "m");
                          resultHTML += formatResultLine("Time, t", t_sol, "s");
                      });
                      
                      showResult(resultHTML);
                      return; // Exit function to prevent the default single summary.
                  }
              } else if (has.vi && has.t && has.d) {
                  if (Math.abs(sol.t) < TOLERANCE) {
                      if (Math.abs(sol.d) > TOLERANCE) throw new Error("Displacement must be zero if time is zero.");
                      sol.a = NaN; // Indeterminate
                  } else {
                      sol.a = 2 * (sol.d - sol.vi * sol.t) / (sol.t * sol.t);
                  }
                  sol.vf = sol.vi + sol.a * sol.t;
              } else if (has.vf && has.a && has.t) {
                  sol.vi = sol.vf - sol.a * sol.t;
                  sol.d = sol.vi * sol.t + 0.5 * sol.a * sol.t * sol.t;
              } else if (has.vf && has.a && has.d) {
                  const A = 0.5 * sol.a;
                  const B = -sol.vf;
                  const C = sol.d;

                  if (Math.abs(A) < TOLERANCE) { // Linear case: a=0
                      if (Math.abs(B) < TOLERANCE) { // vf=0
                          if (Math.abs(C) > TOLERANCE) throw new Error("Displacement must be zero if Vf and a are zero.");
                          sol.t = NaN; // If d=0, vf=0, a=0, time is indeterminate.
                          sol.vi = 0;
                      } else { // vf != 0
                          sol.t = C / B; // d = vf*t (since a=0, vi=vf)
                      }
                      if (sol.t < -TOLERANCE) throw new Error("Calculation resulted in negative time.");
                      sol.t = Math.max(0, sol.t);
                      sol.vi = sol.vf - sol.a * sol.t;
                  } else { // Quadratic case: a!=0
                      const disc = B * B - 4 * A * C;
                      if (disc < -TOLERANCE) throw new Error("No real solution for time.");

                      const sqrtDisc = Math.sqrt(Math.max(0, disc));
                      const t1 = (-B + sqrtDisc) / (2 * A);
                      const t2 = (-B - sqrtDisc) / (2 * A);
                      
                      const validTimes = [t1, t2]
                          .filter(t => t >= -TOLERANCE)
                          .map(t => Math.max(0, t));

                      const uniqueTimes = [...new Set(validTimes.map(t => t.toPrecision(10)))].map(s => parseFloat(s));

                      if (uniqueTimes.length === 0) throw new Error("No positive real solution for time.");

                      let resultHTML = '';
                      uniqueTimes.sort((a, b) => a - b).forEach((t_sol, index) => {
                          const vi_sol = sol.vf - sol.a * t_sol;
                          resultHTML += `<div class="group-title">Solution ${index + 1}</div>`;
                          resultHTML += formatResultLine("Initial Velocity, V<sub>i</sub>", vi_sol, "m/s");
                          resultHTML += formatResultLine("Final Velocity, V<sub>f</sub>", sol.vf, "m/s");
                          resultHTML += formatResultLine("Acceleration, a", sol.a, "m/s²");
                          resultHTML += formatResultLine("Displacement, d", sol.d, "m");
                          resultHTML += formatResultLine("Time, t", t_sol, "s");
                      });
                      
                      showResult(resultHTML);
                      return; // Exit function
                  }
              } else if (has.vf && has.t && has.d) {
                  if (Math.abs(sol.t) < TOLERANCE) {
                      if (Math.abs(sol.d) > TOLERANCE) throw new Error("Displacement must be zero if time is zero.");
                      sol.a = NaN; // Indeterminate
                      sol.vi = sol.vf;
                  } else {
                      sol.vi = (2 * sol.d) / sol.t - sol.vf;
                      sol.a = (sol.vf - sol.vi) / sol.t;
                  }
              } else if (has.a && has.t && has.d) {
                  if (Math.abs(sol.t) < TOLERANCE) {
                      if (Math.abs(sol.d) > TOLERANCE) throw new Error("Displacement must be zero if time is zero.");
                      sol.vi = NaN; // Indeterminate
                      sol.vf = NaN; // Indeterminate
                  } else {
                      sol.vi = (sol.d - 0.5 * sol.a * sol.t * sol.t) / sol.t;
                      sol.vf = sol.vi + sol.a * sol.t;
                  }
              } else {
                  throw new Error("Unexpected combination of inputs.");
              }

              let resultHTML = `<div class="group-title">1D Kinematics Results</div>`;
              resultHTML += formatResultLine("Initial Velocity, V<sub>i</sub>", sol.vi, "m/s");
              resultHTML += formatResultLine("Final Velocity, V<sub>f</sub>", sol.vf, "m/s");
              resultHTML += formatResultLine("Acceleration, a", sol.a, "m/s²");
              resultHTML += formatResultLine("Displacement, d", sol.d, "m");
              resultHTML += formatResultLine("Time, t", sol.t, "s");
              showResult(resultHTML);

          } catch (e) {
              console.error("1D Calc Error:", e);
              showError("1D Calculation Error: " + e.message);
          }
        }

        // --- 2D Projectile Motion Calculation ---
        function calculateBasicMode(g) {
            globalG = g;
            const vi = getFloatValue("vi", true);
            const dx = getFloatValue("dx", true);
            const dy = getFloatValue("dy", true);
            const angleDeg = getFloatValue("angle", true);
            const timeOptional = getFloatValue("time", true);
            const inputs = { vi, dx, dy, angle: angleDeg };
            let providedCount = 0;
            let missingKeys = [];
            for (const key in inputs) {
                const value = inputs[key];
                if (value !== null && isFinite(value)) {
                    providedCount++;
                } else {
                    missingKeys.push(key);
                }
            }
            if (providedCount !== 3) {
                showNote("2D: Please fill in exactly <strong>three</strong> of V<sub>i</sub>, &Delta;x, &Delta;y, &theta;.");
                resetAnimation();
                return;
            }
            if (missingKeys.length !== 1) {
                console.error("Internal Error:", missingKeys);
                showError("Internal error: Could not determine the variable to calculate.");
                resetAnimation();
                return;
            }
            const missingVar = missingKeys[0];
            let t_flight, finalVi, finalAngleRad, finalDx, finalDy;
            let angleRad = (inputs.angle !== null && isFinite(inputs.angle)) ? inputs.angle * Math.PI / 180 : null;
            let tan1, angle1, angle2;
            try {
                switch (missingVar) {
                    case "dx":
                        if (inputs.vi === null || angleRad === null || inputs.dy === null) throw new Error("Inputs V<sub>i</sub>, &theta;, and &Delta;y are required.");
                        finalVi = inputs.vi;
                        finalAngleRad = angleRad;
                        finalDy = inputs.dy;
                        if (finalVi <= 0) throw new Error("Initial velocity must be positive.");
                        const Viy_calc = finalVi * Math.sin(finalAngleRad);
                        const A = 0.5 * g;
                        const B = -Viy_calc;
                        const C = finalDy;
                        const disc = B * B - 4 * A * C;
                        if (disc < -TOLERANCE) throw new Error("No real solution for time.");
                        const sqrtDisc = Math.sqrt(Math.max(0, disc));
                        const t1_dx = (-B + sqrtDisc) / (2 * A);
                        const t2_dx = (-B - sqrtDisc) / (2 * A);
                        if (t1_dx < -TOLERANCE && t2_dx < -TOLERANCE) throw new Error("Negative time calculated.");
                        t_flight = Math.max(t1_dx, t2_dx);
                        if (t_flight < -TOLERANCE) throw new Error("No positive time solution.");
                        t_flight = Math.max(0, t_flight);
                        finalDx = finalVi * Math.cos(finalAngleRad) * t_flight;
                        break;
                    case "dy":
                        if (inputs.vi === null || angleRad === null || inputs.dx === null) throw new Error("Inputs V<sub>i</sub>, &theta;, and &Delta;x are required.");
                        finalVi = inputs.vi;
                        finalAngleRad = angleRad;
                        finalDx = inputs.dx;
                        if (finalVi <= 0) throw new Error("Initial velocity must be positive.");
                        const Vix_calc_dy = finalVi * Math.cos(finalAngleRad);
                        if (Math.abs(Vix_calc_dy) < TOLERANCE) {
                            if (Math.abs(finalDx) > TOLERANCE) throw new Error("For vertical launch, horizontal displacement must be zero.");
                            throw new Error("Cannot calculate &Delta;y without time for vertical launch.");
                        }
                        t_flight = finalDx / Vix_calc_dy;
                        if (t_flight < -TOLERANCE) throw new Error("Negative time calculated.");
                        t_flight = Math.max(0, t_flight);
                        finalDy = finalVi * Math.sin(finalAngleRad) * t_flight - 0.5 * g * t_flight * t_flight;
                        break;
                    case "vi":
                        if (angleRad === null || inputs.dx === null || inputs.dy === null) throw new Error("Inputs &theta;, &Delta;x, and &Delta;y are required.");
                        finalAngleRad = angleRad;
                        finalDx = inputs.dx;
                        finalDy = inputs.dy;
                        if (finalVi <= 0) throw new Error("Initial velocity must be positive.");
                        const cosTheta = Math.cos(finalAngleRad);
                        const sinTheta = Math.sin(finalAngleRad);
                        if (Math.abs(cosTheta) < TOLERANCE) {
                             if (Math.abs(finalDx) > TOLERANCE) throw new Error("For vertical launch, dx must be zero.");
                             throw new Error("Cannot calculate V<sub>i</sub> for vertical launch without time.");
                        }
                        const tanTheta = sinTheta / cosTheta;
                        const term1 = tanTheta * finalDx - finalDy;
                        const numerator = g * finalDx * finalDx;
                        const denominator = 2 * cosTheta * cosTheta * term1;
                        if (Math.abs(denominator) < TOLERANCE) {
                             if (Math.abs(term1) < TOLERANCE) {
                                  throw new Error("Infinite speed required.");
                             } else {
                                  throw new Error("Internal error calculating V<sub>i</sub>.");
                             }
                        }
                        if (numerator / denominator < -TOLERANCE) {
                            throw new Error("Negative square encountered in V<sub>i</sub> calculation.");
                        }
                        const Vi_squared = Math.max(0, numerator / denominator);
                        finalVi = Math.sqrt(Vi_squared);
                        const Vix_calc_vi = finalVi * cosTheta;
                        if (Math.abs(Vix_calc_vi) < TOLERANCE) {
                             if (Math.abs(finalDx) > TOLERANCE) throw new Error("Internal error: Vix is zero.");
                             throw new Error("Cannot determine time for vertical launch without time.");
                        }
                        t_flight = finalDx / Vix_calc_vi;
                        if (t_flight < -TOLERANCE) throw new Error("Negative time calculated.");
                        t_flight = Math.max(0, t_flight);
                        break;
                    case "angle":
                        if (inputs.vi === null || inputs.dx === null || inputs.dy === null) throw new Error("Inputs V<sub>i</sub>, &Delta;x, and &Delta;y are required.");
                        finalVi = inputs.vi;
                        finalDx = inputs.dx;
                        finalDy = inputs.dy;
                        if (finalVi <= 0) throw new Error("Initial velocity must be positive.");
                        if (Math.abs(finalDx) < TOLERANCE) {
                            const A_vert = 0.5 * g;
                            const B_vert = -finalVi;
                            const C_vert = finalDy;
                            const disc_vert = B_vert * B_vert - 4 * A_vert * C_vert;
                            if (disc_vert < -TOLERANCE) throw new Error("Target &Delta;y unreachable for vertical launch.");
                            const sqrtDisc_vert = Math.sqrt(Math.max(0, disc_vert));
                            const t1_vert = (-B_vert + sqrtDisc_vert) / (2 * A_vert);
                            const t2_vert = (-B_vert - sqrtDisc_vert) / (2 * A_vert);
                            if (t1_vert < -TOLERANCE && t2_vert < -TOLERANCE) throw new Error("No positive time for vertical launch.");
                            t_flight = Math.max(t1_vert, t2_vert);
                            if (t_flight < -TOLERANCE) throw new Error("No positive time found.");
                            t_flight = Math.max(0, t_flight);
                            finalAngleRad = Math.PI / 2;
                        } else {
                            const A_angle = (g * finalDx * finalDx) / (2 * finalVi * finalVi);
                            const B_angle = -finalDx;
                            const C_angle = finalDy + A_angle;
                            if (Math.abs(A_angle) < TOLERANCE) {
                                if (Math.abs(B_angle) < TOLERANCE) {
                                     throw new Error("Internal error: dx=0 case missed.");
                                }
                                const tan_theta = C_angle / (-B_angle);
                                finalAngleRad = Math.atan(tan_theta);
                            } else {
                                const disc_angle = B_angle * B_angle - 4 * A_angle * C_angle;
                                if (disc_angle < -TOLERANCE) throw new Error("No real launch angle solution.");
                                const sqrtDisc_angle = Math.sqrt(Math.max(0, disc_angle));
                                tan1 = (-B_angle + sqrtDisc_angle) / (2 * A_angle);
                                const tan2 = (-B_angle - sqrtDisc_angle) / (2 * A_angle);
                                angle1 = Math.atan(tan1);
                                angle2 = Math.atan(tan2);
                                finalAngleRad = angle2;
                            }
                            const Vix_calc_ang = finalVi * Math.cos(finalAngleRad);
                            if (Math.abs(Vix_calc_ang) < TOLERANCE) throw new Error("Internal error: Vix is zero.");
                            t_flight = finalDx / Vix_calc_ang;
                            if (t_flight < -TOLERANCE) throw new Error("Negative time calculated.");
                            t_flight = Math.max(0, t_flight);
                        }
                        break;
                    default:
                        throw new Error("Unexpected error: Could not determine missing variable.");
                }

                if (!isFinite(t_flight) || t_flight < -TOLERANCE) {
                    throw new Error("Invalid time of flight calculated.");
                }
                t_flight = Math.max(0, t_flight);
                const finalAngleDeg = finalAngleRad * 180 / Math.PI;
                const Vix = finalVi * Math.cos(finalAngleRad);
                const Viy = finalVi * Math.sin(finalAngleRad);
                globalVix = Vix;
                globalViy = Viy;
                const t_peak = (Math.abs(g) > TOLERANCE && Viy > TOLERANCE) ? Viy / g : 0;
                const h_max = (t_peak > 0) ? (Viy * t_peak - 0.5 * g * t_peak * t_peak) : 0;
                const Vfx = Vix;
                const Vfy = Viy - g * t_flight;
                const Vf_mag = Math.sqrt(Vfx * Vfx + Vfy * Vfy);
                const Vf_angle_rad = Math.atan2(Vfy, Vfx);
                const Vf_angle_deg = Vf_angle_rad * 180 / Math.PI;

                let resultHTML = `<div class="result">`;
                resultHTML += `<div class="group-title">Calculated Result</div>`;
                switch (missingVar) {
                    case "vi": resultHTML += formatResultLine("Initial Velocity, V<sub>i</sub>", finalVi, "m/s"); break;
                    case "angle": resultHTML += formatResultLine("Launch Angle, &theta;", finalAngleDeg, "°"); break;
                    case "dy": resultHTML += formatResultLine("Vertical Displacement, &Delta;y", finalDy, "m"); break;
                    case "dx": resultHTML += formatResultLine("Horizontal Displacement, &Delta;x", finalDx, "m"); break;
                }
                if (missingVar === 'angle' && angle1 !== undefined && angle2 !== undefined && Math.abs(angle1 - angle2) > TOLERANCE) {
                     const chosenAngle = finalAngleRad;
                     const otherAngle = (Math.abs(chosenAngle - angle1) < TOLERANCE) ? angle2 : angle1;
                     resultHTML += `<p style="font-size: 0.9em; color: var(--label-color);"><em>Note: A second launch angle solution exists: ${(otherAngle * 180 / Math.PI).toFixed(2)}°</em></p>`;
                }
                resultHTML += `<div class="group-title">Trajectory Summary</div>`;
                resultHTML += formatResultLine("Time of Flight, t", t_flight, "s");
                resultHTML += formatResultLine("Max Height (above launch)", h_max, "m");
                resultHTML += formatResultLine("Time to Max Height", t_peak, "s");
                resultHTML += `<div class="group-title">Initial Conditions</div>`;
                resultHTML += formatResultLine("Initial Velocity, V<sub>i</sub>", finalVi, "m/s");
                resultHTML += formatResultLine("Launch Angle, &theta;", finalAngleDeg, "°");
                resultHTML += formatResultLine("Initial Horizontal Vel., V<sub>ix</sub>", Vix, "m/s");
                resultHTML += formatResultLine("Initial Vertical Vel., V<sub>iy</sub>", Viy, "m/s");
                resultHTML += `<div class="group-title">Final State (at t = ${t_flight.toFixed(2)}s)</div>`;
                resultHTML += formatResultLine("Final Horizontal Disp., &Delta;x", finalDx, "m");
                resultHTML += formatResultLine("Final Vertical Disp., &Delta;y", finalDy, "m");
                resultHTML += formatResultLine("Final Velocity Mag., V<sub>f</sub>", Vf_mag, "m/s");
                resultHTML += formatResultLine("Final Velocity Angle, &phi;", Vf_angle_deg, "°");
                resultHTML += formatResultLine("Final Horizontal Vel., V<sub>fx</sub>", Vfx, "m/s");
                resultHTML += formatResultLine("Final Vertical Vel., V<sub>fy</sub>", Vfy, "m/s");
                if (timeOptional !== null && isFinite(timeOptional) && timeOptional >= 0) {
                    const t_opt = Math.min(timeOptional, t_flight);
                    const t_opt_calc = timeOptional;
                    const dx_opt = Vix * t_opt_calc;
                    const dy_opt = Viy * t_opt_calc - 0.5 * g * t_opt_calc * t_opt_calc;
                    const vx_opt = Vix;
                    const vy_opt = Viy - g * t_opt_calc;
                    const speed_opt = Math.sqrt(vx_opt * vx_opt + vy_opt * vy_opt);
                    const angle_opt = Math.atan2(vy_opt, vx_opt) * 180 / Math.PI;
                    resultHTML += `<div class="group-title">State at Optional Time (t = ${t_opt_calc.toFixed(2)}s)</div>`;
                    resultHTML += formatResultLine("Horizontal Disp., &Delta;x", dx_opt, "m");
                    resultHTML += formatResultLine("Vertical Disp., &Delta;y", dy_opt, "m");
                    resultHTML += formatResultLine("Horizontal Vel., V<sub>x</sub>", vx_opt, "m/s");
                    resultHTML += formatResultLine("Vertical Vel., V<sub>y</sub>", vy_opt, "m/s");
                    resultHTML += formatResultLine("Speed", speed_opt, "m/s");
                    resultHTML += formatResultLine("Velocity Angle", angle_opt, "°");
                }
                resultHTML += `</div>`;
                showResult(resultHTML);
                prepareAndDrawTrajectory(Vix, Viy, t_flight, g, dy);
            } catch (e) {
                console.error("Basic Mode Calc Error:", e);
                showError("2D Mode Calculation Error: " + e.message);
                resetAnimation();
            }
        }

        // --- 2D Projectile Motion (Design Mode) Calculation ---
        function calculateDesignMode(g) {
            globalG = g;
            const dx_target = getFloatValue("dxDesign");
            const dy_target = getFloatValue("dyDesign");
            const landingAngleDeg = getFloatValue("landingAngle");
            if (isNaN(dx_target) || isNaN(dy_target) || isNaN(landingAngleDeg)) {
                showNote("Design Mode: Please fill in target &Delta;x, &Delta;y, and desired landing angle &phi;.");
                resetAnimation();
                return;
            }
            if (Math.abs(g) < TOLERANCE) {
                showError("Design mode requires non-zero gravitational acceleration (g).");
                resetAnimation();
                return;
            }
            if (Math.abs(dx_target) < TOLERANCE) {
                showError("Design mode requires a non-zero Horizontal Displacement (&Delta;x).");
                resetAnimation();
                return;
            }
            try {
                const phi_rad = landingAngleDeg * Math.PI / 180;
                const tan_phi = Math.tan(phi_rad);
                const tan_theta = (2 * dy_target / dx_target) - tan_phi;
                const theta_rad = Math.atan(tan_theta);
                const theta_deg = theta_rad * 180 / Math.PI;
                const denominator_VixSq = tan_theta - tan_phi;
                let finalVi;
                if (Math.abs(denominator_VixSq) < TOLERANCE) {
                    if (Math.abs(dy_target) > TOLERANCE) {
                        throw new Error("Calculation error: Launch angle approx equals landing angle, but target &Delta;y is not zero.");
                    }
                    const sin2theta = Math.sin(2 * theta_rad);
                    if (Math.abs(sin2theta) < TOLERANCE) throw new Error("Cannot calculate V<sub>i</sub>: Launch angle is near 0° or 90°.");
                    const Vi_sq = g * dx_target / sin2theta;
                    if (Vi_sq < -TOLERANCE) throw new Error("Calculation resulted in negative V<sub>i</sub>².");
                    finalVi = Math.sqrt(Math.max(0, Vi_sq));
                } else {
                    const Vix_sq = g * dx_target / denominator_VixSq;
                    if (Vix_sq < -TOLERANCE) {
                        throw new Error("Calculation resulted in negative V<sub>ix</sub>².");
                    }
                    const Vix = Math.sqrt(Math.max(0, Vix_sq));
                    const cosTheta = Math.cos(theta_rad);
                    if (Math.abs(cosTheta) < TOLERANCE) throw new Error("Calculated launch angle is vertical.");
                    finalVi = Vix / cosTheta;
                }
                const finalAngleRad = theta_rad;
                const finalAngleDeg = theta_deg;
                if (!isFinite(finalVi) || finalVi <= 0) {
                    throw new Error("Calculated Initial Velocity (V<sub>i</sub>) is invalid.");
                }
                const Vix = finalVi * Math.cos(finalAngleRad);
                const Viy = finalVi * Math.sin(finalAngleRad);
                globalVix = Vix;
                globalViy = Viy;
                if (Math.abs(Vix) < TOLERANCE) throw new Error("Horizontal velocity Vix is near zero.");
                const t_flight = dx_target / Vix;
                if (t_flight < -TOLERANCE) throw new Error("Negative time of flight calculated.");
                const t_flight_nonNeg = Math.max(0, t_flight);
                const t_peak = (Math.abs(g) > TOLERANCE && Viy > TOLERANCE) ? Viy / g : 0;
                const h_max = (t_peak > 0) ? (Viy * t_peak - 0.5 * g * t_peak * t_peak) : 0;
                const Vfx_check = Vix;
                const Vfy_check = Viy - g * t_flight_nonNeg;
                const Vf_mag_check = Math.sqrt(Vfx_check * Vfx_check + Vfy_check * Vfy_check);
                const Vf_angle_rad_check = Math.atan2(Vfy_check, Vfx_check);
                const Vf_angle_deg_check = Vf_angle_rad_check * 180 / Math.PI;
                const dx_check = Vix * t_flight_nonNeg;
                const dy_check = Viy * t_flight_nonNeg - 0.5 * g * t_flight_nonNeg * t_flight_nonNeg;
                let resultHTML = `<div class="result">`;
                resultHTML += `<div class="group-title">Design Mode Results: Required Launch</div>`;
                resultHTML += formatResultLine("Launch Angle, &theta;", finalAngleDeg, "°");
                resultHTML += formatResultLine("Initial Velocity, V<sub>i</sub>", finalVi, "m/s");
                resultHTML += `<div class="group-title">Resulting Trajectory</div>`;
                resultHTML += formatResultLine("Time of Flight, t", t_flight_nonNeg, "s");
                resultHTML += formatResultLine("Max Height (above launch)", h_max, "m");
                resultHTML += formatResultLine("Time to Max Height", t_peak, "s");
                resultHTML += `<div class="group-title">Initial Velocity Components</div>`;
                resultHTML += formatResultLine("Initial Horizontal Vel., V<sub>ix</sub>", Vix, "m/s");
                resultHTML += formatResultLine("Initial Vertical Vel., V<sub>iy</sub>", Viy, "m/s");
                resultHTML += `<div class="group-title">Achieved Final State (Verification)</div>`;
                resultHTML += formatResultLine("Final Horizontal Disp., &Delta;x", dx_check, "m");
                resultHTML += formatResultLine("Final Vertical Disp., V<sub>fy</sub>", dy_check, "m");
                resultHTML += formatResultLine("Final Velocity Mag., V<sub>f</sub>", Vf_mag_check, "m/s");
                resultHTML += formatResultLine("Final Velocity Angle, &phi;", Vf_angle_deg_check, "°");
                resultHTML += formatResultLine("Final Horizontal Vel., V<sub>fx</sub>", Vfx_check, "m/s");
                resultHTML += formatResultLine("Final Vertical Vel., V<sub>fy</sub>", Vfy_check, "m/s");
                resultHTML += `</div>`;
                showResult(resultHTML);
                prepareAndDrawTrajectory(Vix, Viy, t_flight_nonNeg, g, dy_target);
            } catch (e) {
                console.error("Design Mode Calc Error:", e);
                showError("Design Mode Calculation Error: " + e.message);
                resetAnimation();
            }
        }

        // NEW: Multi-Object 1D Calculation
        function calculateMultiObject1DMode() {
            multiObjectData = []; // Clear previous data
            let minTime = 0;
            let maxTime = 0;
            let minPosition = 0; // Initialize minPosition to 0 to ensure 0 is considered for scaling
            let maxPosition = 0; // Initialize maxPosition to 0 to ensure 0 is considered for scaling
            let meetingPoints = []; // Store {t, x} for meeting points

            const objectsToProcess = [];
            // Object 1
            objectsToProcess.push({
                id: 1,
                x0: getFloatValue("obj1_x0"),
                v0: getFloatValue("obj1_v0"),
                a: getFloatValue("obj1_a"),
                color: objectColors[0],
                label: "Object 1"
            });

            // Object 2
            objectsToProcess.push({
                id: 2,
                x0: getFloatValue("obj2_x0"),
                v0: getFloatValue("obj2_v0"),
                a: getFloatValue("obj2_a"),
                color: objectColors[1],
                label: "Object 2"
            });

            // Object 3 (if visible)
            if (showObject3) {
                objectsToProcess.push({
                    id: 3,
                    x0: getFloatValue("obj3_x0"),
                    v0: getFloatValue("obj3_v0"),
                    a: getFloatValue("obj3_a"),
                    color: objectColors[2],
                    label: "Object 3"
                });
            }

            // Validate inputs for each object
           
            for (const obj of objectsToProcess) {
                if (isNaN(obj.x0) || isNaN(obj.v0) || isNaN(obj.a)) {
                    showError(`Multi-Object 1D: Please ensure all inputs (Initial Position, Initial Velocity, Acceleration) are valid numbers for ${obj.label}.`);
                    resetAnimation();
                    return;
                }
                multiObjectData.push(obj); // Store valid input data
            }

            if (multiObjectData.length < 2) {
                showNote("Multi-Object 1D Mode: Please enter data for at least two objects.");
                resetAnimation();
                return;
            }

            // Calculate meeting points and determine max time/position for graph
            let resultHTML = `<div class="result"><div class="group-title">Meeting Points</div>`;
            let hasMeetingPoints = false;

            // Compare all pairs of objects
            for (let i = 0; i < multiObjectData.length; i++) {
                for (let j = i + 1; j < multiObjectData.length; j++) {
                    const objA = multiObjectData[i];
                    const objB = multiObjectData[j];

                    // Equation: (0.5*aA - 0.5*aB)t^2 + (v0A - v0B)t + (x0A - x0B) = 0
                    const A_quad = 0.5 * (objA.a - objB.a);
                    const B_quad = objA.v0 - objB.v0;
                    const C_quad = objA.x0 - objB.x0;

                    let times = [];

                    if (Math.abs(A_quad) < TOLERANCE) { // Linear equation: Bt + C = 0
                        if (Math.abs(B_quad) < TOLERANCE) { // Both A and B are zero
                            if (Math.abs(C_quad) < TOLERANCE) {
                                // Identical trajectories
                                resultHTML += `<p><strong>${objA.label} and ${objB.label}:</strong> <span>Always at the same position.</span></p>`;
                                hasMeetingPoints = true;
                                // For graphing, we'll consider a default time range
                                maxTime = Math.max(maxTime, 10);
                            } else {
                                // Parallel lines, never meet
                                resultHTML += `<p><strong>${objA.label} and ${objB.label}:</strong> <span>Never meet.</span></p>`;
                            }
                        } else { // Linear solution: t = -C / B
                            const t_meet = -C_quad / B_quad;
                            if (t_meet >= -TOLERANCE) { // Only consider non-negative time
                                times.push(Math.max(0, t_meet));
                            }
                        }
                    } else { // Quadratic equation
                        const discriminant = B_quad * B_quad - 4 * A_quad * C_quad;
                        if (discriminant >= -TOLERANCE) { // Real solutions
                            const sqrtDisc = Math.sqrt(Math.max(0, discriminant));
                            const t1 = (-B_quad + sqrtDisc) / (2 * A_quad);
                            const t2 = (-B_quad - sqrtDisc) / (2 * A_quad);

                            if (t1 >= -TOLERANCE) times.push(Math.max(0, t1));
                            if (t2 >= -TOLERANCE && Math.abs(t1 - t2) > TOLERANCE) times.push(Math.max(0, t2)); // Avoid duplicate times
                        }
                    }

                    times = times.sort((a, b) => a - b); // Sort times in ascending order

                    if (times.length > 0) {
                        hasMeetingPoints = true;
                        resultHTML += `<div class="group-title">${objA.label} and ${objB.label} Meeting Points</div>`;
                        times.forEach(t => {
                            const x_meet_A = objA.x0 + objA.v0 * t + 0.5 * objA.a * t * t;
                            meetingPoints.push({ t, x: x_meet_A, objects: [objA.id, objB.id] });
                            resultHTML += formatResultLine(`Time`, t, "s");
                            resultHTML += formatResultLine(`Position`, x_meet_A, "m");
                        });
                    } else if (Math.abs(A_quad) > TOLERANCE || Math.abs(B_quad) > TOLERANCE || Math.abs(C_quad) > TOLERANCE) {
                         // Only show "never meet" if they are not identical and no meeting points found
                        resultHTML += `<p><strong>${objA.label} and ${objB.label}:</strong> <span>Never meet.</span></p>`;
                    }
                }
            }

            if (!hasMeetingPoints && multiObjectData.length >= 2) {
                resultHTML += `<p>No meeting points found for any pair of objects.</p>`;
            } else if (multiObjectData.length < 2) {
                resultHTML += `<p>Enter data for at least two objects to find meeting points.</p>`;
            }
            resultHTML += `</div>`;
            showResult(resultHTML);

            // Determine max time for graph based on meeting points or default
            if (meetingPoints.length > 0) {
                maxTime = Math.max(...meetingPoints.map(p => p.t)) * 1.2; // Extend time a bit beyond last meeting
            } else {
                // If no meeting points, use a default time or base on initial velocities/accelerations
                maxTime = 10; // Default to 10 seconds if no meeting points
                // Could be more sophisticated: e.g., if objects are moving apart, keep time short; if converging, estimate a reasonable time.
            }
            maxTime = Math.max(maxTime, 5); // Ensure a minimum time for visualization

            // Generate points for each object's trajectory for graphing
            globalPoints = []; // Reuse globalPoints for multi-object trajectories
            let allXValues = [];

            multiObjectData.forEach(obj => {
                const objPoints = [];
                const numGraphPoints = 200; // Number of points to draw the curve smoothly
                for (let i = 0; i <= numGraphPoints; i++) {
                    const t = (i / numGraphPoints) * maxTime;
                    const x = obj.x0 + obj.v0 * t + 0.5 * obj.a * t * t;
                    objPoints.push({ t, x });
                    allXValues.push(x);
                }
                globalPoints.push({
                    id: obj.id,
                    label: obj.label,
                    color: obj.color,
                    trajectory: objPoints // This is where the trajectory data is attached
                });
            });

            // Determine graph scale and offsets for Position-Time graph
            // Ensure 0 is always included in the position range for correct axis placement
            minPosition = Math.min(0, ...allXValues, ...multiObjectData.map(obj => obj.x0));
            maxPosition = Math.max(0, ...allXValues, ...multiObjectData.map(obj => obj.x0));

            const canvasWidth = trajectoryCanvas.width;
            const canvasHeight = trajectoryCanvas.height;
            const availableWidth = canvasWidth - 2 * GRAPH_MARGIN;
            const availableHeight = canvasHeight - 2 * GRAPH_MARGIN;

            const rangeX = maxTime; // Time range (starts from 0)
            const rangeY = maxPosition - minPosition; // Position range

            globalScaleX = (Math.abs(rangeX) < TOLERANCE) ? 1 : availableWidth / rangeX;
            globalScaleY = (Math.abs(rangeY) < TOLERANCE) ? 1 : availableHeight / rangeY;

            // globalOffsetX is the canvas X for data t=0 (left edge of plotting area)
            globalOffsetX = GRAPH_MARGIN;
            // globalOffsetY is the canvas Y for data x=globalMinPosition (bottom of plot area).
            // This means that the canvas Y coordinate for the data point `globalMinPosition` is `canvasHeight - GRAPH_MARGIN`.
            globalOffsetY = canvasHeight - GRAPH_MARGIN;

            // Store meeting points globally for drawing
            globalMeetingPoints = meetingPoints;
            globalMaxTime = maxTime; // Store max time for animation slider
            globalMinPosition = minPosition; // Store for state display scaling
            globalMaxPosition = maxPosition; // Store for state display scaling

            prepareAndDrawMultiObject1DGraph(); // Draw the graph
            resetAnimation(); // Reset animation to start
        }

        // --- Optimizer Mathematical Functions ---
        function toRadians(degrees) {
            return degrees * Math.PI / 180;
        }

        function toDegrees(radians) {
            return radians * 180 / Math.PI;
        }

        function optimizerTimeOfFlight(v, theta, g, h) {
            const vy = v * Math.sin(theta);
            const discriminant = vy * vy + 2 * g * h;
            if (discriminant < 0) return 0;
            return (vy + Math.sqrt(discriminant)) / g;
        }

        function optimizerRange(v, theta, g, h) {
            const vx = v * Math.cos(theta);
            return vx * optimizerTimeOfFlight(v, theta, g, h);
        }

        function optimizerApexHeight(v, theta, g, h) {
            const vy = v * Math.sin(theta);
            return h + (vy * vy) / (2 * g);
        }

        function optimizeAngle(v, g, h) {
            // Golden section search for optimal angle
            let a = 0.0001;
            let b = Math.PI / 2 - 0.0001;
            const phi = (Math.sqrt(5) - 1) / 2;
            
            let c = b - phi * (b - a);
            let d = a + phi * (b - a);
            let fc = optimizerRange(v, c, g, h);
            let fd = optimizerRange(v, d, g, h);
            
            for (let i = 0; i < 80; i++) {
                if (fc < fd) {
                    a = c;
                    c = d;
                    fc = fd;
                    d = a + phi * (b - a);
                    fd = optimizerRange(v, d, g, h);
                } else {
                    b = d;
                    d = c;
                    fd = fc;
                    c = b - phi * (b - a);
                    fc = optimizerRange(v, c, g, h);
                }
                if (b - a < 1e-9) break;
            }
            
            const theta = (a + b) / 2;
            return {
                theta: theta,
                bestRange: optimizerRange(v, theta, g, h)
            };
        }

        // NEW: Optimizer Mode Calculation
        function calculateOptimizerMode() {
            const g = getFloatValue("acceleration", false) || G_DEFAULT;
            
            // Get trajectory A parameters
            const angleA = getFloatValue("angleA");
            const speedA = getFloatValue("speedA");
            const heightA = getFloatValue("heightA");
            
            // Get trajectory B parameters
            const angleB = getFloatValue("angleB");
            const speedB = getFloatValue("speedB");
            const heightB = getFloatValue("heightB");
            
            // Validate inputs
            if (isNaN(angleA) || isNaN(speedA) || isNaN(heightA) || 
                isNaN(angleB) || isNaN(speedB) || isNaN(heightB)) {
                showNote("Optimizer Mode: Please fill in all trajectory parameters.");
                resetAnimation();
                return;
            }
            
            if (speedA <= 0 || speedB <= 0) {
                showError("Initial speeds must be positive.");
                resetAnimation();
                return;
            }
            
            if (angleA < 0.1 || angleA > 89.9 || angleB < 0.1 || angleB > 89.9) {
                showError("Launch angles must be between 0.1° and 89.9°.");
                resetAnimation();
                return;
            }
            
            try {
                // Calculate trajectories
                const thetaA = toRadians(angleA);
                const thetaB = toRadians(angleB);
                
                const rangeA = optimizerRange(speedA, thetaA, g, heightA);
                const rangeB = optimizerRange(speedB, thetaB, g, heightB);
                const timeA = optimizerTimeOfFlight(speedA, thetaA, g, heightA);
                const timeB = optimizerTimeOfFlight(speedB, thetaB, g, heightB);
                const heightMaxA = optimizerApexHeight(speedA, thetaA, g, heightA);
                const heightMaxB = optimizerApexHeight(speedB, thetaB, g, heightB);
                
                // Calculate optimal angles
                const optimalA = optimizeAngle(speedA, g, heightA);
                const optimalB = optimizeAngle(speedB, g, heightB);
                
                // Calculate flight times for optimal trajectories
                const optimalTimeA = optimizerTimeOfFlight(speedA, optimalA.theta, g, heightA);
                const optimalTimeB = optimizerTimeOfFlight(speedB, optimalB.theta, g, heightB);
                
                // Store animation data
                optimizerAnimationData.trajectoryA = {
                    v: speedA, theta: thetaA, g: g, h: heightA,
                    range: rangeA, time: timeA, heightMax: heightMaxA
                };
                optimizerAnimationData.trajectoryB = {
                    v: speedB, theta: thetaB, g: g, h: heightB,
                    range: rangeB, time: timeB, heightMax: heightMaxB
                };
                optimizerAnimationData.optimalA = {
                    v: speedA, theta: optimalA.theta, g: g, h: heightA,
                    range: optimalA.bestRange, time: optimalTimeA
                };
                optimizerAnimationData.optimalB = {
                    v: speedB, theta: optimalB.theta, g: g, h: heightB,
                    range: optimalB.bestRange, time: optimalTimeB
                };
                
                // Generate results
                let resultHTML = `<div class="group-title">Optimizer Results</div>`;
                
                resultHTML += `<div class="group-title">Trajectory A</div>`;
                resultHTML += formatResultLine("Launch Angle, θ<sub>A</sub>", angleA, "°");
                resultHTML += formatResultLine("Range", rangeA, "m");
                resultHTML += formatResultLine("Time of Flight", timeA, "s");
                resultHTML += formatResultLine("Max Height", heightMaxA, "m");
                
                resultHTML += `<div class="group-title">Trajectory B</div>`;
                resultHTML += formatResultLine("Launch Angle, θ<sub>B</sub>", angleB, "°");
                resultHTML += formatResultLine("Range", rangeB, "m");
                resultHTML += formatResultLine("Time of Flight", timeB, "s");
                resultHTML += formatResultLine("Max Height", heightMaxB, "m");
                
                resultHTML += `<div class="group-title">Optimal Angles</div>`;
                resultHTML += formatResultLine("Optimal Angle A", toDegrees(optimalA.theta), "°");
                resultHTML += formatResultLine("Max Range A", optimalA.bestRange, "m");
                resultHTML += formatResultLine("Optimal Angle B", toDegrees(optimalB.theta), "°");
                resultHTML += formatResultLine("Max Range B", optimalB.bestRange, "m");
                
                showResult(resultHTML);
                
                // Draw the optimizer visualization
                prepareAndDrawOptimizer();
                
            } catch (e) {
                console.error("Optimizer Calc Error:", e);
                showError("Optimizer Calculation Error: " + e.message);
                resetAnimation();
            }
        }

        /**
         * Draws the X and Y axes for the multi-object 1D graph.
         * @param {CanvasRenderingContext2D} ctx - The 2D rendering context of the canvas.
         * @param {number} width - The width of the canvas.
         * @param {number} height - The height of the canvas.
         * @param {number} margin - The margin from the canvas edges.
         */
        function drawAxesForMultiObject(ctx, width, height, margin) {
            ctx.strokeStyle = '#aaa'; // A neutral gray color for axes
            ctx.lineWidth = 1;

            // X-axis (Position = 0 line)
            // Calculate the canvas Y coordinate for position 0
            const xAxisY_canvas = dataToCanvasY(0);
            ctx.beginPath();
            ctx.moveTo(margin, xAxisY_canvas);
            ctx.lineTo(width - margin, xAxisY_canvas);
            ctx.stroke();

            // Y-axis (Time = 0 line)
            const yAxisX_canvas = dataToCanvasX(0); // This should be 'margin'
            ctx.beginPath();
            ctx.moveTo(yAxisX_canvas, margin);
            ctx.lineTo(yAxisX_canvas, height - margin);
            ctx.stroke();

            // X-axis label
            ctx.fillStyle = "var(--label-color)";
            ctx.font = "12px Arial";
            ctx.textAlign = "center";
            ctx.textBaseline = "top";
            ctx.fillText("Time (s)", margin + (width - 2 * margin) / 2, xAxisY_canvas + 10);

            // Y-axis label
            ctx.save();
            ctx.translate(yAxisX_canvas - 30, margin + (height - 2 * margin) / 2); // Adjust X position for rotated text
            ctx.rotate(-Math.PI / 2);
            ctx.textAlign = "center";
            ctx.textBaseline = "bottom";
            ctx.fillText("Position (m)", 0, 0);
            ctx.restore();
        }

        // NEW: Function to draw the Multi-Object 1D graph
        function prepareAndDrawMultiObject1DGraph() {
            const ctx = trajectoryCanvas.getContext("2d");
            if (!ctx || globalPoints.length === 0) return;

            ctx.clearRect(0, 0, trajectoryCanvas.width, trajectoryCanvas.height);

            // Draw the axes using the dedicated function
            drawAxesForMultiObject(ctx, trajectoryCanvas.width, trajectoryCanvas.height, GRAPH_MARGIN);

            // Draw each object's trajectory
            globalPoints.forEach(obj => {
                ctx.beginPath();
                obj.trajectory.forEach((pt, i) => {
                    const canvasX = dataToCanvasX(pt.t);
                    const canvasY = dataToCanvasY(pt.x);

                    if (i === 0) {
                        ctx.moveTo(canvasX, canvasY);
                    } else {
                        ctx.lineTo(canvasX, canvasY);
                    }
                });
                ctx.strokeStyle = obj.color;
                ctx.lineWidth = 2;
                ctx.stroke();

                // Draw label for each object at its starting point
                const startPt = obj.trajectory[0];
                const startCanvasX = dataToCanvasX(startPt.t);
                const startCanvasY = dataToCanvasY(startPt.x);
                ctx.fillStyle = obj.color;
                ctx.font = "12px Arial";
                ctx.textAlign = "left";
                ctx.textBaseline = "bottom";
                ctx.fillText(obj.label, startCanvasX + 10, startCanvasY - 5);
            });

            // Draw meeting points
            globalMeetingPoints.forEach(mp => {
                const canvasX = dataToCanvasX(mp.t);
                const canvasY = dataToCanvasY(mp.x);

                ctx.beginPath();
                ctx.arc(canvasX, canvasY, 6, 0, 2 * Math.PI);
                ctx.fillStyle = "red"; // Meeting points are red
                ctx.fill();
                ctx.strokeStyle = "white";
                ctx.lineWidth = 1;
                ctx.stroke();

                ctx.fillStyle = "var(--marker-text-color)";
                ctx.font = "11px Arial";
                ctx.textAlign = "center";
                ctx.textBaseline = "bottom";
                ctx.fillText(`t=${mp.t.toFixed(2)}s, x=${mp.x.toFixed(2)}m`, canvasX, canvasY - 10);
            });
        }

        // NEW: Draw current time marker and object positions for Multi-Object 1D
        function drawMultiObject1DCurrentState(ctx, t_current) {
            if (globalPoints.length === 0) return;

            // Draw a vertical line for the current time
            const lineX = dataToCanvasX(t_current);
            ctx.strokeStyle = "rgba(0, 0, 0, 0.7)";
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]); // Dashed line
            ctx.beginPath();
            ctx.moveTo(lineX, GRAPH_MARGIN); // From top margin
            ctx.lineTo(lineX, trajectoryCanvas.height - GRAPH_MARGIN); // To bottom margin
            ctx.stroke();
            ctx.setLineDash([]); // Reset line dash

            // Draw a circle for each object at its current position
            globalPoints.forEach(obj => {
                const x_current = obj.trajectory.find(pt => pt.t >= t_current - TOLERANCE)?.x || obj.trajectory[obj.trajectory.length - 1].x;
                const canvasX = dataToCanvasX(t_current);
                const canvasY = dataToCanvasY(x_current);

                ctx.beginPath();
                ctx.arc(canvasX, canvasY, 6, 0, 2 * Math.PI);
                ctx.fillStyle = obj.color; // Use object's color
                ctx.fill();
                ctx.strokeStyle = "white";
                ctx.lineWidth = 1;
                ctx.stroke();
            });
        }


        // --- Trajectory Data Generation and Drawing Setup ---
        function prepareAndDrawTrajectory(Vix, Viy, t_flight, g, y_end) {
            if (!trajectoryCanvas) return;
            globalPoints = [];
            global_t_flight = Math.max(0, t_flight);
            // If the final displacement (y_end) is negative, shift the trajectory upward
            let verticalShift = (y_end < 0) ? -y_end : 0;
            // Save the vertical shift globally so the ball and peak label use it
            globalVerticalShift = verticalShift;
            const numPoints = 100;
            const dt = (global_t_flight > TOLERANCE) ? global_t_flight / numPoints : 0;
            for (let i = 0; i <= numPoints; i++) {
                const t = i * dt;
                const x = Vix * t;
                // Apply vertical shift to ensure the landing point is drawn at y=0
                const y = Viy * t - 0.5 * g * t * t + verticalShift;
                globalPoints.push({ x, y, t });
            }
            if (globalPoints.length === 0 || Math.abs(globalPoints[globalPoints.length - 1].t - global_t_flight) > TOLERANCE) {
                const x_final = Vix * global_t_flight;
                const y_final = Viy * global_t_flight - 0.5 * g * global_t_flight * global_t_flight + verticalShift;
                if (globalPoints.length > 0) {
                    globalPoints[globalPoints.length - 1] = { x: x_final, y: y_final, t: global_t_flight };
                } else {
                    globalPoints.push({ x: x_final, y: y_final, t: global_t_flight });
                }
            }
            if (globalPoints.length === 0) {
                console.warn("No trajectory points generated.");
                resetAnimation();
                return;
            }
            const xs = globalPoints.map(p => p.x);
            const ys = globalPoints.map(p => p.y);
            const minX = Math.min(0, ...xs);
            const maxX = Math.max(0, ...xs);
            const minY = Math.min(0, ...ys);
            const maxY = Math.max(0, ...ys);
            const marginFactor = 0.15;
            const canvasWidth = trajectoryCanvas.width;
            const canvasHeight = trajectoryCanvas.height;
            const availableWidth = canvasWidth * (1 - marginFactor * 2);
            const availableHeight = canvasHeight * (1 - marginFactor * 2);
            const rangeX = (maxX - minX);
            const rangeY = (maxY - minY);
            globalScale = Math.min(
                (Math.abs(rangeX) < TOLERANCE) ? 1 : availableWidth / rangeX,
                (Math.abs(rangeY) < TOLERANCE) ? 1 : availableHeight / rangeY
            );
            globalScale = Math.max(1e-6, globalScale);
            globalScale = Math.min(1e6, globalScale);
            const trajWidthScaled = rangeX * globalScale;
            globalOffsetX = (canvasWidth - trajWidthScaled) / 2 - minX * globalScale;
            // Set globalOffsetY so that the lowest point appears near the bottom margin
            globalOffsetY = canvasHeight * (1 - marginFactor) + minY * globalScale;
            resetAnimation();
        }

        // --- Canvas Drawing Functions ---
        function drawStaticTrajectory() {
            const ctx = trajectoryCanvas.getContext("2d");
            if (!ctx || globalPoints.length === 0) return;
            ctx.clearRect(0, 0, trajectoryCanvas.width, trajectoryCanvas.height);
            // Draw axes with a hardcoded neutral dark gray color
            ctx.strokeStyle = "#555555";
            ctx.lineWidth = 1;
            const originY_canvas = globalOffsetY - (0 * globalScale);
            ctx.beginPath();
            ctx.moveTo(0, originY_canvas);
            ctx.lineTo(trajectoryCanvas.width, originY_canvas);
            ctx.stroke();
            const originX_canvas = globalOffsetX + (0 * globalScale);
            ctx.beginPath();
            ctx.moveTo(originX_canvas, 0);
            ctx.lineTo(originX_canvas, trajectoryCanvas.height);
            ctx.stroke();
            // Draw the trajectory path using a hardcoded blue color (#1e90ff)
            ctx.beginPath();
            globalPoints.forEach((pt, i) => {
                const canvasX = globalOffsetX + pt.x * globalScale;
                const canvasY = globalOffsetY - pt.y * globalScale;
                if (i === 0) {
                    ctx.moveTo(canvasX, canvasY);
                } else {
                    ctx.lineTo(canvasX, canvasY);
                }
            });
            ctx.strokeStyle = "#1e90ff";
            ctx.lineWidth = 2;
            ctx.stroke();
            // Draw key markers
            const startPoint = globalPoints[0];
            const endPoint = globalPoints[globalPoints.length - 1];
            let peakPoint = startPoint;
            if (Math.abs(globalG) > TOLERANCE && globalViy > TOLERANCE) {
                const t_peak = globalViy / globalG;
                if (t_peak > 0 && t_peak <= global_t_flight + TOLERANCE) {
                    peakPoint = {
                        x: globalVix * t_peak,
                        // Apply the vertical shift to the peak label calculation
                        y: globalViy * t_peak - 0.5 * globalG * t_peak * t_peak + globalVerticalShift,
                        t: t_peak
                    };
                } else {
                    peakPoint = globalPoints.reduce((max, p) => p.y > max.y ? p : max, startPoint);
                }
            } else {
                peakPoint = globalPoints.reduce((max, p) => p.y > max.y ? p : max, startPoint);
            }
            drawMarker(ctx, startPoint, "green", "Start");
            if (peakPoint.y > Math.max(startPoint.y, endPoint.y) + (0.01 / globalScale)) {
                drawMarker(ctx, peakPoint, "orange", "Peak");
            }
            drawMarker(ctx, endPoint, "red", "Landing");
        }

        function drawMarker(ctx, pt, color, label) {
            if (!pt) return;
            const cx = globalOffsetX + pt.x * globalScale;
            const cy = globalOffsetY - pt.y * globalScale;
            ctx.beginPath();
            ctx.arc(cx, cy, 5, 0, 2 * Math.PI);
            ctx.fillStyle = color;
            ctx.fill();
            ctx.strokeStyle = "rgba(0,0,0,0.5)";
            ctx.lineWidth = 1;
            ctx.stroke();
            ctx.fillStyle = "var(--marker-text-color)";
            ctx.font = "11px Arial";
            ctx.textAlign = "left";
            ctx.textBaseline = "bottom";
            let labelX = cx + 8;
            let labelY = cy - 5;
            if (cx > trajectoryCanvas.width - 50) {
                ctx.textAlign = "right";
                labelX = cx - 8;
            }
            if (cy < 20) {
                 labelY = cy + 15;
            }
            ctx.fillText(label, labelX, labelY);
        }

        function drawProjectile(ctx, t_current) {
            if (!isFinite(globalVix) || !isFinite(globalViy) || !isFinite(globalG)) return;
            const x_current = globalVix * t_current;
            // Add the global vertical shift so the projectile follows the shifted trajectory
            const y_current = globalViy * t_current - 0.5 * globalG * t_current * t_current + globalVerticalShift;
            const ballX = globalOffsetX + x_current * globalScale;
            const ballY = globalOffsetY - y_current * globalScale;
            ctx.beginPath();
            ctx.arc(ballX, ballY, 6, 0, 2 * Math.PI);
            ctx.fillStyle = "blue";
            ctx.fill();
            ctx.strokeStyle = "white";
            ctx.lineWidth = 1;
            ctx.stroke();
        }

        // --- Optimizer Drawing Functions ---
        function prepareAndDrawOptimizer() {
            if (!optimizerAnimationData.trajectoryA || !optimizerAnimationData.trajectoryB) return;
            
            const ctx = trajectoryCanvas.getContext("2d");
            if (!ctx) return;
            
            // Calculate world bounds for scaling
            const trajectories = [optimizerAnimationData.trajectoryA, optimizerAnimationData.trajectoryB];
            const optimals = [optimizerAnimationData.optimalA, optimizerAnimationData.optimalB];
            
            let maxX = 0, maxY = 0;
            [...trajectories, ...optimals].forEach(traj => {
                if (traj && traj.range) {
                    maxX = Math.max(maxX, traj.range);
                }
                if (traj && traj.heightMax) {
                    maxY = Math.max(maxY, traj.heightMax);
                }
            });
            
            // Add some padding
            maxX *= 1.15;
            maxY *= 1.15;
            
            const canvasWidth = trajectoryCanvas.width;
            const canvasHeight = trajectoryCanvas.height;
            const margin = 40;
            
            // Calculate scale and offsets
            globalScale = Math.min(
                (canvasWidth - 2 * margin) / maxX,
                (canvasHeight - 2 * margin) / maxY
            );
            globalOffsetX = margin;
            globalOffsetY = canvasHeight - margin;
            
            // Set global flight time for animation
            global_t_flight = Math.max(optimizerAnimationData.trajectoryA.time, optimizerAnimationData.trajectoryB.time);
            
            drawOptimizerVisualization();
            resetAnimation();
        }

        function drawOptimizerVisualization() {
            const ctx = trajectoryCanvas.getContext("2d");
            if (!ctx) return;
            
            ctx.clearRect(0, 0, trajectoryCanvas.width, trajectoryCanvas.height);
            
            // Draw background and axes
            drawOptimizerBackground(ctx);
            
            // Draw legend
            drawOptimizerLegend(ctx);
            
            // Draw envelopes if enabled
            if (document.getElementById("showTrajectoryA").checked && document.getElementById("showEnvelopeA").checked) {
                drawTrajectoryEnvelope(ctx, optimizerAnimationData.trajectoryA, optimizerColors.trajectoryA);
            }
            if (document.getElementById("showTrajectoryB").checked && document.getElementById("showEnvelopeB").checked) {
                drawTrajectoryEnvelope(ctx, optimizerAnimationData.trajectoryB, optimizerColors.trajectoryB);
            }
            
            // Draw optimal paths if enabled
            if (document.getElementById("showOptimalPaths").checked) {
                drawSingleTrajectory(ctx, optimizerAnimationData.optimalA, optimizerColors.optimalA, 2, false);
                drawSingleTrajectory(ctx, optimizerAnimationData.optimalB, optimizerColors.optimalB, 2, false);
            }
            
            // Draw current trajectories
            if (document.getElementById("showTrajectoryA").checked) {
                drawSingleTrajectory(ctx, optimizerAnimationData.trajectoryA, optimizerColors.trajectoryA, 3, true);
            }
            if (document.getElementById("showTrajectoryB").checked) {
                drawSingleTrajectory(ctx, optimizerAnimationData.trajectoryB, optimizerColors.trajectoryB, 3, true);
            }
        }

        function drawOptimizerBackground(ctx) {
            const canvasWidth = trajectoryCanvas.width;
            const canvasHeight = trajectoryCanvas.height;
            
            // Draw ground line
            ctx.strokeStyle = "var(--axis-color)";
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(0, globalOffsetY);
            ctx.lineTo(canvasWidth, globalOffsetY);
            ctx.stroke();
            
            // Draw vertical line at origin
            ctx.beginPath();
            ctx.moveTo(globalOffsetX, 0);
            ctx.lineTo(globalOffsetX, canvasHeight);
            ctx.stroke();
        }

        function drawOptimizerLegend(ctx) {
            const canvasWidth = trajectoryCanvas.width;
            const legendX = canvasWidth - 120; // Position from right edge
            const legendY = 15;
            const lineLength = 20;
            const lineSpacing = 20;
            const textOffset = 25;
            
            ctx.font = "12px Arial";
            ctx.textAlign = "left";
            ctx.textBaseline = "middle";
            
            let currentY = legendY;
            
            // Only show legend items for visible trajectories
            if (document.getElementById("showTrajectoryA").checked) {
                // Trajectory A (thick line)
                ctx.strokeStyle = optimizerColors.trajectoryA;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(legendX, currentY);
                ctx.lineTo(legendX + lineLength, currentY);
                ctx.stroke();
                ctx.fillStyle = optimizerColors.trajectoryA;
                ctx.fillText("Trajectory A", legendX + textOffset, currentY);
                currentY += lineSpacing;
            }
            
            if (document.getElementById("showTrajectoryB").checked) {
                // Trajectory B (thick line)
                ctx.strokeStyle = optimizerColors.trajectoryB;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(legendX, currentY);
                ctx.lineTo(legendX + lineLength, currentY);
                ctx.stroke();
                ctx.fillStyle = optimizerColors.trajectoryB;
                ctx.fillText("Trajectory B", legendX + textOffset, currentY);
                currentY += lineSpacing;
            }
            
            if (document.getElementById("showOptimalPaths").checked) {
                // Optimal A (thin line)
                ctx.strokeStyle = optimizerColors.optimalA;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(legendX, currentY);
                ctx.lineTo(legendX + lineLength, currentY);
                ctx.stroke();
                ctx.fillStyle = optimizerColors.optimalA;
                ctx.fillText("Optimal A", legendX + textOffset, currentY);
                currentY += lineSpacing;
                
                // Optimal B (thin line)
                ctx.strokeStyle = optimizerColors.optimalB;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(legendX, currentY);
                ctx.lineTo(legendX + lineLength, currentY);
                ctx.stroke();
                ctx.fillStyle = optimizerColors.optimalB;
                ctx.fillText("Optimal B", legendX + textOffset, currentY);
                currentY += lineSpacing;
            }
            
            if ((document.getElementById("showTrajectoryA").checked && document.getElementById("showEnvelopeA").checked) ||
                (document.getElementById("showTrajectoryB").checked && document.getElementById("showEnvelopeB").checked)) {
                // Envelope indicator (dotted line example)
                ctx.setLineDash([5, 5]);
                ctx.strokeStyle = "#888";
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(legendX, currentY);
                ctx.lineTo(legendX + lineLength, currentY);
                ctx.stroke();
                ctx.setLineDash([]); // Reset line dash
                ctx.fillStyle = "#888";
                ctx.fillText("Envelope", legendX + textOffset, currentY);
            }
        }

        function drawTrajectoryEnvelope(ctx, trajectory, color) {
            if (!trajectory) return;
            
            const v = trajectory.v;
            const g = trajectory.g;
            const h = trajectory.h;
            
            // Calculate envelope bounds
            const xMax = Math.sqrt((v * v / g) * ((v * v / g) + 2 * h));
            const numPoints = 100;
            
            ctx.save();
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.setLineDash([8, 6]);
            ctx.globalAlpha = 0.6;
            
            ctx.beginPath();
            for (let i = 0; i <= numPoints; i++) {
                const x = xMax * (i / numPoints);
                const y = h + (v * v) / (2 * g) - (g * x * x) / (2 * v * v);
                
                const canvasX = globalOffsetX + x * globalScale;
                const canvasY = globalOffsetY - y * globalScale;
                
                if (i === 0) {
                    ctx.moveTo(canvasX, canvasY);
                } else {
                    ctx.lineTo(canvasX, canvasY);
                }
            }
            ctx.stroke();
            
            ctx.restore();
        }

        function drawSingleTrajectory(ctx, trajectory, color, lineWidth, showProjectile) {
            if (!trajectory) return;
            
            const v = trajectory.v;
            const theta = trajectory.theta;
            const g = trajectory.g;
            const h = trajectory.h;
            const time = trajectory.time;
            
            const numPoints = 100;
            
            // Draw trajectory path
            ctx.strokeStyle = color;
            ctx.lineWidth = lineWidth;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            ctx.beginPath();
            for (let i = 0; i <= numPoints; i++) {
                const t = time * (i / numPoints);
                const x = v * Math.cos(theta) * t;
                const y = h + v * Math.sin(theta) * t - 0.5 * g * t * t;
                
                const canvasX = globalOffsetX + x * globalScale;
                const canvasY = globalOffsetY - y * globalScale;
                
                if (i === 0) {
                    ctx.moveTo(canvasX, canvasY);
                } else {
                    ctx.lineTo(canvasX, canvasY);
                }
            }
            ctx.stroke();
            
            // Draw projectile at current animation time if requested
            if (showProjectile && autoAnimating) {
                const currentTime = Math.min(animationCurrentTime(), time);
                const x = v * Math.cos(theta) * currentTime;
                const y = h + v * Math.sin(theta) * currentTime - 0.5 * g * currentTime * currentTime;
                
                const ballX = globalOffsetX + x * globalScale;
                const ballY = globalOffsetY - y * globalScale;
                
                // Draw glowing projectile
                ctx.save();
                ctx.shadowColor = color;
                ctx.shadowBlur = 15;
                ctx.beginPath();
                ctx.arc(ballX, ballY, 6, 0, 2 * Math.PI);
                ctx.fillStyle = color;
                ctx.fill();
                ctx.restore();
            }
        }

        function animationCurrentTime() {
            const sliderValue = parseFloat(trajectorySlider.value);
            return (sliderValue / 100) * global_t_flight;
        }

        // --- Animation & Slider Control ---
        function updateAnimationFrame() {
            const ctx = trajectoryCanvas.getContext("2d");
            if (!ctx) return;

            const mode = getSelectedMode();
            const sliderValue = parseFloat(trajectorySlider.value);
            let t_current = 0;

            if (mode === "multiObject1D") {
                if (globalMaxTime > TOLERANCE) {
                    t_current = (sliderValue / 100) * globalMaxTime;
                }
                prepareAndDrawMultiObject1DGraph(); // Redraw static graph
                drawMultiObject1DCurrentState(ctx, t_current); // Draw dynamic state
                updateStateDisplayMultiObject(t_current);
            } else if (mode === "optimizer") {
                if (!isFinite(global_t_flight)) return;
                if (global_t_flight > TOLERANCE) {
                    t_current = (sliderValue / 100) * global_t_flight;
                }
                drawOptimizerVisualization(); // Redraw with animation
                updateOptimizerStateDisplay(t_current);
            } else { // Basic and Design modes (2D)
                if (!isFinite(global_t_flight)) return;
                if (global_t_flight > TOLERANCE) {
                    t_current = (sliderValue / 100) * global_t_flight;
                }
                drawStaticTrajectory();
                drawProjectile(ctx, t_current);
                updateStateDisplay(t_current);
            }
        }

        function startAutoAnimation() {
            if (autoAnimating) return;
            const mode = getSelectedMode();
            let totalTime;
            
            if (mode === "multiObject1D") {
                totalTime = globalMaxTime;
            } else if (mode === "optimizer") {
                totalTime = global_t_flight;
            } else {
                totalTime = global_t_flight;
            }

            if (!isFinite(totalTime) || totalTime <= 0) return;

            autoAnimating = true;
            animationStartTime = null;
            startStopButton.textContent = "Stop";

            function animateFrame(timestamp) {
                if (!autoAnimating) return;
                if (!animationStartTime) {
                    animationStartTime = timestamp - (pausedProgress * ANIMATION_DURATION);
                }
                const elapsed = timestamp - animationStartTime;
                let progress = Math.min(elapsed / ANIMATION_DURATION, 1);
                trajectorySlider.value = progress * 100;
                updateAnimationFrame();
                if (progress < 1) {
                    animationFrameId = requestAnimationFrame(animateFrame);
                } else {
                    autoAnimating = false;
                    startStopButton.textContent = "Start";
                    pausedProgress = 0;
                    trajectorySlider.value = 100;
                    updateAnimationFrame();
                }
            }
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            animationFrameId = requestAnimationFrame(animateFrame);
        }

        function toggleAnimation() {
            if (autoAnimating) {
                autoAnimating = false;
                if (animationFrameId) cancelAnimationFrame(animationFrameId);
                pausedProgress = parseFloat(trajectorySlider.value) / 100;
                startStopButton.textContent = "Start";
            } else {
                if (parseFloat(trajectorySlider.value) >= 99.9) {
                     pausedProgress = 0;
                     trajectorySlider.value = 0;
                } else {
                      pausedProgress = parseFloat(trajectorySlider.value) / 100;
                }
                startAutoAnimation();
            }
        }

        function resetAnimation() {
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            autoAnimating = false;
            pausedProgress = 0;
            trajectorySlider.value = 0;
            startStopButton.textContent = "Start";

            const mode = getSelectedMode();
            if (mode === "multiObject1D") {
                if (globalPoints && globalPoints.length > 0) { // Check globalPoints for multi-object
                    prepareAndDrawMultiObject1DGraph();
                    updateStateDisplayMultiObject(0);
                } else {
                    const ctx = trajectoryCanvas.getContext("2d");
                    if (ctx) ctx.clearRect(0, 0, trajectoryCanvas.width, trajectoryCanvas.height);
                    updateStateDisplayMultiObject(0);
                }
            } else if (mode === "optimizer") {
                if (optimizerAnimationData.trajectoryA && optimizerAnimationData.trajectoryB) {
                    drawOptimizerVisualization();
                    updateOptimizerStateDisplay(0);
                } else {
                    const ctx = trajectoryCanvas.getContext("2d");
                    if (ctx) ctx.clearRect(0, 0, trajectoryCanvas.width, trajectoryCanvas.height);
                    updateOptimizerStateDisplay(0);
                }
            } else { // 2D modes
                if (globalPoints && globalPoints.length > 0) {
                     updateAnimationFrame(); // This will call drawStaticTrajectory and drawProjectile(0)
                } else {
                     const ctx = trajectoryCanvas.getContext("2d");
                     if (ctx) ctx.clearRect(0, 0, trajectoryCanvas.width, trajectoryCanvas.height);
                     updateStateDisplay(0);
                }
            }
        }

        function handleSliderInput() {
            if (autoAnimating) {
                autoAnimating = false;
                if (animationFrameId) cancelAnimationFrame(animationFrameId);
                startStopButton.textContent = "Start";
            }
            updateAnimationFrame();
        }

        function handleSliderChange() {
            pausedProgress = parseFloat(trajectorySlider.value) / 100;
            updateAnimationFrame();
        }

        // NEW: Handle clicks on the canvas for meeting points
        function handleCanvasClick(event) {
            const mode = getSelectedMode();
            if (mode !== "multiObject1D" || globalMeetingPoints.length === 0) {
                return;
            }

            const rect = trajectoryCanvas.getBoundingClientRect();
            const clickX = event.clientX - rect.left;
            const clickY = event.clientY - rect.top;

            for (const mp of globalMeetingPoints) {
                const canvasX = dataToCanvasX(mp.t);
                const canvasY = dataToCanvasY(mp.x);

                const distance = Math.sqrt(
                    Math.pow(clickX - canvasX, 2) + Math.pow(clickY - canvasY, 2)
                );

                if (distance <= MEETING_POINT_CLICK_RADIUS) {
                    if (animationFrameId) cancelAnimationFrame(animationFrameId);
                    autoAnimating = false;
                    startStopButton.textContent = "Start";

                    const newSliderValue = (mp.t / globalMaxTime) * 100;
                    trajectorySlider.value = newSliderValue;
                    pausedProgress = newSliderValue / 100;
                    updateAnimationFrame();
                    break;
                }
            }
        }

        // --- State Display Update (for 2D) ---
        function updateStateDisplay(t) {
            if (typeof globalVix !== 'number' || typeof globalViy !== 'number' || !isFinite(globalVix) || !isFinite(globalViy) || typeof globalG !== 'number' || !isFinite(globalG)) {
                 stateDisplayValues.innerHTML = `
                     <p><strong>Time:</strong> <span>-- s</span></p>
                     <p><strong>&Delta;x:</strong> <span>-- m</span></p>
                     <p><strong>&Delta;y:</strong> <span>-- m</span></p>
                     <p><strong>V<sub>x</sub>:</strong> <span>-- m/s</span></p>
                     <p><strong>V<sub>y</sub>:</strong> <span>-- m/s</span></p>
                     <p><strong>Speed:</strong> <span>-- m/s</span></p>
                     <p><strong>Angle:</strong> <span>-- °</span></p>
                 `;
                 return;
            }
            const display_t = Math.max(0, t);
            const dx = globalVix * display_t;
            const dy = globalViy * display_t - 0.5 * globalG * display_t * display_t;
            const vx = globalVix;
            const vy = globalViy - globalG * display_t;
            const speed = Math.sqrt(vx * vx + vy * vy);
            const angle = Math.atan2(vy, vx) * 180 / Math.PI;
            stateDisplayValues.innerHTML = `
                <p><strong>Time:</strong> <span>${display_t.toFixed(2)} s</span></p>
                <p><strong>&Delta;x:</strong> <span>${dx.toFixed(2)} m</span></p>
                <p><strong>&Delta;y:</strong> <span>${dy.toFixed(2)} m</span></p>
                <p><strong>V<sub>x</sub>:</strong> <span>${vx.toFixed(2)} m/s</span></p>
                <p><strong>V<sub>y</sub>:</strong> <span>${vy.toFixed(2)} m/s</span></p>
                <p><strong>Speed:</strong> <span>${speed.toFixed(2)} m/s</span></p>
                <p><strong>Angle:</strong> <span>${angle.toFixed(2)} °</span></p>
            `;
        }

        // NEW: State Display Update for Multi-Object 1D
        function updateStateDisplayMultiObject(t) {
            let html = `<p><strong>Time:</strong> <span>${t.toFixed(2)} s</span></p>`;
            if (multiObjectData.length === 0) {
                html += `
                    <p><strong>Position:</strong> <span>-- m</span></p>
                    <p><strong>Velocity:</strong> <span>-- m/s</span></p>
                `;
            } else {
                multiObjectData.forEach(obj => {
                    const x_current = obj.x0 + obj.v0 * t + 0.5 * obj.a * t * t;
                    const v_current = obj.v0 + obj.a * t;
                    html += `
                        <div class="group-title" style="margin-top: 1rem; color: ${obj.color};">${obj.label}</div>
                        <p><strong>Position:</strong> <span>${x_current.toFixed(2)} m</span></p>
                        <p><strong>Velocity:</strong> <span>${v_current.toFixed(2)} m/s</span></p>
                    `;
                });
            }
            stateDisplayValues.innerHTML = html;
        }

        // NEW: State Display Update for Optimizer
        function updateOptimizerStateDisplay(t) {
            let html = `<p><strong>Time:</strong> <span>${t.toFixed(2)} s</span></p>`;
            
            if (optimizerAnimationData.trajectoryA && document.getElementById("showTrajectoryA").checked) {
                const trajA = optimizerAnimationData.trajectoryA;
                const x_A = trajA.v * Math.cos(trajA.theta) * t;
                const y_A = trajA.h + trajA.v * Math.sin(trajA.theta) * t - 0.5 * trajA.g * t * t;
                const vx_A = trajA.v * Math.cos(trajA.theta);
                const vy_A = trajA.v * Math.sin(trajA.theta) - trajA.g * t;
                const speed_A = Math.sqrt(vx_A * vx_A + vy_A * vy_A);
                
                html += `
                    <div class="group-title" style="margin-top: 1rem; color: ${optimizerColors.trajectoryA};">Trajectory A</div>
                    <p><strong>Position:</strong> <span>(${x_A.toFixed(2)}, ${y_A.toFixed(2)}) m</span></p>
                    <p><strong>Velocity:</strong> <span>(${vx_A.toFixed(2)}, ${vy_A.toFixed(2)}) m/s</span></p>
                    <p><strong>Speed:</strong> <span>${speed_A.toFixed(2)} m/s</span></p>
                `;
            }
            
            if (optimizerAnimationData.trajectoryB && document.getElementById("showTrajectoryB").checked) {
                const trajB = optimizerAnimationData.trajectoryB;
                const x_B = trajB.v * Math.cos(trajB.theta) * t;
                const y_B = trajB.h + trajB.v * Math.sin(trajB.theta) * t - 0.5 * trajB.g * t * t;
                const vx_B = trajB.v * Math.cos(trajB.theta);
                const vy_B = trajB.v * Math.sin(trajB.theta) - trajB.g * t;
                const speed_B = Math.sqrt(vx_B * vx_B + vy_B * vy_B);
                
                html += `
                    <div class="group-title" style="margin-top: 1rem; color: ${optimizerColors.trajectoryB};">Trajectory B</div>
                    <p><strong>Position:</strong> <span>(${x_B.toFixed(2)}, ${y_B.toFixed(2)}) m</span></p>
                    <p><strong>Velocity:</strong> <span>(${vx_B.toFixed(2)}, ${vy_B.toFixed(2)}) m/s</span></p>
                    <p><strong>Speed:</strong> <span>${speed_B.toFixed(2)} m/s</span></p>
                `;
            }
            
            stateDisplayValues.innerHTML = html;
        }


        // --- Main Calculation Dispatcher ---
        function calculate() {
            const mode = getSelectedMode();
            try {
                if (mode === "1d") {
                     clearMessages();
                     showNote("1D Mode: Fill in <strong>exactly three</strong> fields.");
                    calculate1DMode();
                } else if (mode === "multiObject1D") { // NEW
                     clearMessages();
                     showNote("Multi-Object 1D Mode: Enter initial position, initial velocity, and acceleration for each object. The graph will show their positions over time and any meeting points.");
                     calculateMultiObject1DMode();
                } else if (mode === "optimizer") { // NEW
                     clearMessages();
                     showNote("Optimizer Mode: Compare two projectile trajectories. Use optimization to find maximum range angles. Visualize trajectory envelopes.");
                     calculateOptimizerMode();
                } else {
                    const accInput = getFloatValue("acceleration");
                    const g = (isFinite(accInput) && accInput > 0) ? accInput : G_DEFAULT;
                     if (!isFinite(accInput) || accInput <= 0) {
                         document.getElementById("acceleration").value = G_DEFAULT;
                     }
                    if (mode === "basic") {
                         clearMessages();
                         showNote("2D Mode: Fill in <strong>exactly three</strong> of V<sub>i</sub>, &Delta;x, &Delta;y, &theta;.");
                        calculateBasicMode(g);
                    } else if (mode === "design") {
                         clearMessages();
                         showNote("Design Mode: Fill in target &Delta;x, &Delta;y, and landing angle &phi;.");
                        calculateDesignMode(g);
                    }
                }
            } catch (err) {
                console.error("Unhandled Calculation Error:", err);
                showError("Calculation Error: " + err.message);
                resetAnimation();
            }
        }
    </script>
</body>
</html>
